# [아이템 65] 리플렉션보다는 인터페이스를 사용하라

### 리플렉션 기능

**리플렉션 기능을 사용하면, 프로그램에서 임의의 클래스에 접근 가능**

- Class 객체
    - 생성자(Constructor), 메서드(Method), 필드(Field) 인스턴스 접근 가능
    - 인스턴스들로 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 조회 가능
    - 실제 생성자(인스턴스 생성), 메서드(호출), 필드(접근) 조작 가능
        - Method.invoke: 어떤 클래스의 어떤 객체가, 어떤 메서드라도 호출 가능 (보안 주의)
- 컴파일 당시 존재하지 않던 클래스도 이용할 수 있다.

### 리플렉션의 단점

- 컴파일타임 타입 검사의 장점을 누릴 수 없다.
    - 예외 검사도 마찬가지로, 존재하지 않거나 접근할 수 없는 메서드 호출 시 런타임 오류 발생 가능
- 코드가 지저분해지고 장황해진다.
- 성능 하락
    - 일반 메서드 호출보다 훨씬 느리다. (저자의 단순 int반환 메서드 - 11배)

### 리플렉션의 올바른 사용

**코드 분석 도구, DI 프레임워크처럼 리플레션이 필요한 경우도 있음**

- 하지만 명백한 단점으로 사용 비중을 줄이는 중
- 필요성을 확신할 수 없다면 필요 없을 가능성 높음

**제한된 형태로 사용해야 단점을 피하고 이점을 누릴 수 있다**

컴파일타임에 이용할 수 없는 클래스를 사용행햐만 하는 경우

→ 비록 컴파일타임이라도 **적절한 인터페이스나 상위클래스**를 이용할 수는 있을 것

→ 리플렉션은 인스턴스 생성에만 쓰고, 인스턴스는 상위 타입으로 참조해 사용하자

**코드 예시**

- Set<String> 인터페이스의 인스턴스를 생성, 정확한 클래스는 명령줄 첫 인수로 확정
- 생성된 집합에서 이후 인수들을 추가한 후, 중복 제거 후 화면 출력
- 출력 순서는 첫 인수로 지정한 클래스에 따라 달라짐

```java
public static void main(String[] args) {
  // 클래스 이름을 Class 객체로 변환
  Class<? extends Set<String>> cl = null;
  try {
    cl = (Class<? extends Set<String>>) Class.forName(args[0]);
  } catch (ClassNotFoundException e) {
    fatalError("Class Not Found");
  }
  // 생성자를 얻는다.
  Constructor<? extends Set<String>> cosn = null;
  try {
    cons = cl.getDeclaredConstructor();
  } catch (NoSuchMethodException e) {
    fatalError("NoArgsConstructor Not Found");
  }
  // 집합의 인스턴스를 만든다.
  Set<String> s = null;
  try {
    s = cons.newInstance();
  } catch (IllegalArgumentException e) {
    fatalError("Can't access to Constructor");
  } catch (InstantiationExcewption e) {
    fatalError("Can't instantiate the class");
  } catch (InvocationTargetException e) {
    fatalError("Constructor throws a error: " + e.getCause());
  } catch (ClassCastException e) {
    fatal("Not implement Set");
  }
  
  // 생성한 집합을 사용한다.
  s.addAll(Arrays.asList(args).subList(1, args.length));
  sout(s);
}
```

**예시가 보여주는 리플렉션의 단점**

- 런타임에 여섯 가지나 되는 예외를 던질 수 있다.
    - 리플렉션 없었다면 모두 컴파일타임 처리 가능한 예외
    - 리플렉션 예외 각각 대신 모든 리플렉션 예외의 상위 클래스인 `ReflectiveOperationException` 사용 가능 (자바 7~)
- 너무 긴 코드 (클래스 이름만으로 인스턴스 생성하기 위해 25줄이나 작성함)
    - 생성자였으면 단 한 줄

두 단점 **모두 객체 생성 부분에만 국한**됨

→ 실제 프로그램에서 이런 제약을 받는 코드는 일부

이후 코드는 Set 인스턴스 사용 할 때와 같음

`Class<? extends Set<String>>` 형변환은 비검사 형변환 경고 발생

- 명시한 클래스가 Set을 구현하지 않아도 형변환은 성공
- 인스턴스 생성 시 `ClassCastException` 발생

**리플렉션이 적합한 또다른 경우**

런타임에 존재하지 않을 수도 있는 다른 클래스, 메서드, 필드와의 의존성 관리

- 여러 버전이 존재하는 외부 패키지 다룰 때 유용
- 가장 오래된 버전 지원하도록 컴파일 → 이후 버전의 클래스와 메서드는 리플렉션으로 접근
- 접근하려는 새로운 클래스, 메서드는 런타임에 존재하지 않을 수도 있다는 점을 명심