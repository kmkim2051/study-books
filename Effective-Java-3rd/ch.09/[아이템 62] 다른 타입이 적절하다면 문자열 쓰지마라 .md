# [아이템 62] 다른 타입이 적절하다면 문자열 사용을 피하라

### 문자열을 쓰지 않아야 할 사례

- 문자열은 다른 **값 타입을 대신**하기에 적합하지 않다.
    - 파일, 네트워크, 키보드 입력을 받을 때 주로 문자열 사용
    - 진짜 문자열이 아니라면 적절한 타입을 사용하자
        - 수치형 → int, float, BigInteger, …
        - Yes/No → boolean
    - **기본 타입이든 참조 타입이든, 적절한 값 타입이 있다면 사용하고 없으면 새로 만들자**
- 문자열은 **열거 타입**을 대신하기 적합하지 않다.
- 문자열은 **혼합 타입**을 대신하기 적합하지 않다.
    - 아래와 같은 방식은 단점이 많음
    `String compoundKey = className + "#" + i.next();`
    - 구분자 ‘#’이 두 요소 중 하나에서 쓰였다면 예상치 못한 결과
    - 각 요소를 개별로 접근하려면 문자열 파싱 필요 → 느리고, 귀찮고, 오류 가능성
    - 적절한 equals, toString compareTo 제공 불가, String 기능에만 의존
    - **private 정적 멤버 클래스로, 전용 클래스를 만들자**
- 문자열은 권한을 표현하기 적합하지 않다.
    - 스레드 지역변수 기능 설계 예시 - 각 스레드가 자신만의 변수를 갖게 하기
        - 클라이언트가 제공한 문자열 키로 스레드별 지역변수 선언
            
            ```java
            // 문자열을 사용해 권한을 구분한 잘못된 예시
            public class ThreadLocal {
              private ThreadLocal() {} // 객체 생성 불가
              
              // 현 스레드의 값을 키로 구분해 저장
              public static void set(String key, Object value);
              
              // 키가 가리키는 현 스레드의 값을 반환
              public static Object get(String key);
            }
            ```
            
            - 스레드 구분용 문자열 키가 전역 이름공간에서 공유되는 문제
                - 각 클라이언트가 고유한 키를 제공해야 함 → 클라이언트간 중복 발생 시 문제
            - 악의적인 클라이언트가 같은 키를 사용할 수도 있음
        - 문자열 대신 위조할 수 없는 키(권한)를 사용해 해결
        
        ```java
        public class ThreadLocal {
          private ThreadLocal() {}
          
          public static class Key {
            Key() {}
          }
          // 위조 불가능한 고유 키 생성
          public static Key getKey() {
            return new Key();
          }
          public static void set(Key key, Object value);
          public static Object get(Key key);
        }
        ```
        
        - 코드 개선
        
        ```java
        // (1) set, get은 정적메서드일 이유가 없으니 Key 클래스의 인스턴스 메서드로
        // (2) Key는 스레드 지역변수 구분이 아닌, 스레드 지역변수 자체가 됨
        // (3) 톱레벨 클래스 ThreadLocal을 제거하고, Key를 ThreadLocal로 변경
        public final class ThreadLocal {
          public ThreadLocal();
          public void set(Object value);
          public Object get();
        }
        
        // get으로 얻은 Object를 형변환해야 하므로, 매개변수화 타입으로 선언
        public final class ThreadLocal<T> {
          // ...
        }
        ```
        

### ThreadLocal 에 관하여

**java.lang.ThreadLocal<T>**

각 **쓰레드마다 독립적인 값**을 저장할 수 있게 해주는 도구

즉, 같은 ThreadLocal 인스턴스를 여러 쓰레드가 사용해도, 서로 간섭하지 않고 **각자 고유한 값을** 가짐

**예시 코드**

```java
public class ThreadLocalExample {
  private static ThreadLocal<Integer> threadLocal = new ThreadLocal<>();

  public static void main(String[] args) {
    Runnable task = () -> {
      // 고유 값 설정
      threadLocal.set((int) (Math.random() * 100));
      try {
        Thread.sleep(100);
        System.out.println(Thread.currentThread().getName() + ": " + threadLocal.get());
      } finally {
        threadLocal.remove(); // 메모리 누수 방지
      }
    };

    new Thread(task, "Thread-A").start();
    new Thread(task, "Thread-B").start();
  }
}
// 출력 예시
Thread-A: 37
Thread-B: 82
```

**작동 원리** 

- ThreadLocal 객체는 하나뿐이지만, **값은 쓰레드마다 다르게 저장됨**
- **Thread 내부에 ThreadLocal 값을 저장할 Map**이 따로 있기 때문

```java
Thread (java.lang.Thread)
 └── ThreadLocalMap threadLocals
      └── Entry[] table (key: ThreadLocal, value: Object)
```

**작동 흐름**

1. `threadLocal.set("value")`을 호출하면:
    - 현재 실행 중인 쓰레드(Thread.currentThread())의 threadLocals 맵을 가져옴
    - `key`는 ThreadLocal 객체 자기 자신
    - `value`는 우리가 저장하려는 값
2. `threadLocal.get()`을 호출하면:
    - 현재 쓰레드의 threadLocals에서 `this(=ThreadLocal 자기자신)`를 key로 값 조회
3. 따라서 **ThreadLocal은 키 역할만 하고, 진짜 저장소는 각 Thread가 들고 있는 Map**임
    
    
    | **Thread 이름** | **Key (ThreadLocal 객체, 같음)** | **Value (Thread 내부 저장된 값, 다름)** |
    | --- | --- | --- |
    | Thread-A | threadLocal | threadLocal → 37 |
    | Thread-B | threadLocal | threadLocal → 42 |

**주의사항**

ThreadLocal을 **쓰레드풀 환경**에서 사용할 때 반드시 **remove()**를 호출

- **일반적인 Thread 환경**
    - new Thread(...).start()로 쓰레드를 만들면
        
        → 쓰레드 실행이 끝나고 사라짐
        
        → 함께 붙어있던 ThreadLocalMap도 GC 대상이 됨
        
- 쓰레드풀(ThreadPool) 환경
    - 쓰레드는 **재사용**됨
        
        (예: ExecutorService, @Async, Web 서버 쓰레드풀, 등등)
        
    
    → Thread 객체는 죽지 않고 살아 있고, 그 안에 있는 ThreadLocalMap도 계속 살아있음
    
    → 여기에 설정한 값도 **계속 남아 있음**
    
    | 메모리 누수 | 쓰레드가 살아있으면 값도 계속 살아 있음 |
    | --- | --- |
    | 잘못된 데이터 사용 | 이전 요청의 정보가 다음 요청에도 참조될 수 있음 (보안 이슈) |
    | GC 방해 | key가 WeakReference지만, value는 Strong Reference → 자동으로는 잘 안 없어짐 |

**사용 예시**

- 스프링
- **`RequestContextHolder` 
Controller나 Service에서  HttpServletRequest를 파라미터로 받지 않아도** 현재 요청 정보 조회 가능
    - DispatcherServlet이 요청 시작 시 RequestAttributes를 setRequestAttributes()로 설정
    - 요청 완료 시 resetRequestAttributes()로 제거 (메모리 누수 방지)

```java
public abstract class RequestContextHolder {
    private static final ThreadLocal<RequestAttributes> requestAttributesHolder = new NamedThreadLocal<>("Request attributes");
    
    public static RequestAttributes getRequestAttributes() { ... }
    public static void setRequestAttributes(RequestAttributes attributes) { ... }
    public static void resetRequestAttributes() { ... }
}

HttpServletRequest req 
  = ((ServletRequestAttributes) RequestContextHolder
																  .getRequestAttributes())
			                            .getRequest();
```

**비동기에서의 한계**

```java
ThreadLocal<String> context = new ThreadLocal<>();
context.set("main-thread-value");

CompletableFuture.runAsync(() -> {
    System.out.println(context.get()); // ❌ null
});
```

- runAsync()는 **새 쓰레드**에서 실행되므로, 기존 쓰레드에 저장된 ThreadLocal 값이 **없음**
- 즉, **ThreadLocal 값은 자동으로 전달되지 않는다**

**InheritableThreadLocal에서의 한계**

InheritableThreadLocal 이란?

- 자식 쓰레드가 생성될 때, **부모 쓰레드의 ThreadLocal 값을 복사**해 줌
    
    ```java
    InheritableThreadLocal<String> context = new InheritableThreadLocal<>();
    context.set("parent");
    
    // Thread.start()로 만든 자식 쓰레드는 값을 복사받음
    Thread child = new Thread(() -> {
        System.out.println(context.get()); // ✅ "parent"
    });
    child.start();
    ```
    
- **한계: ThreadPool에서는 작동하지 않음**
    - 새 쓰레드를 생성하지 않아 부모-자식 관계가 아니므로
- **해결책**
    - ThreadLocal 값을 수동 전달
        
        ```java
        String val = threadLocal.get();
        executorService.submit(() -> {
            threadLocal.set(val);
            try {
                // 작업 수행
            } finally {
                threadLocal.remove();
            }
        });
        ```
        
    - TaskDecorator (Spring @Async 전용)
    - Spring Security 5.3+ 에서의 해결책
        - DelegatingSecurityContextRunnable, DelegatingSecurityContextExecutorService