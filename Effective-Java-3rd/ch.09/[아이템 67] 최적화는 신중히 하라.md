# [아이템 67] 최적화는 신중히 하라

### 최적화 격언

1. 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 많다.
2. 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다.
3. 최적화 할 때는 다음 두 규칙을 따르라.
    1. 하지 마라
    2. (전문가 한정) 아직 하지 마라. 완벽한 해법을 찾을 때 까지는 하지 마라.

**최적화는 해로운 결과로 이어지기 쉽고, 섣불리 진행하면 더욱 그렇다.**

(=빠르지도 않고, 제대로 동작하지도 않고 수정하기 어려운 소프트웨어)

### 빠른 프로그램보다는 좋은 프로그램을 작성하라

성능 때문에 견고한 구조를 희생하지 말자

- 좋은 프로그램이지만 성능이 나오지 않는다면?
    - 아키텍처 자체가 최적화 할 수 있는 방안을 도출해줌
- 좋은 프로그램은 정보 은닉 원칙을 따름
    - 나머지 시스템에 영향을 미치지 않고 개별 구성요소를 독립적으로 설계 가능

**프로그램 완성 전까지 성능을 무시하라는 말이 아니다!**

- 구현상 문제는 추후 최적화가 가능하지만, 아키텍처 결함이라면 시스템 전체를 다시 작성해야 할 수도 있음
- 설계의 기본 틀을 변경하다보면 꼬인 구조의 시스템이 만들어짐
- 설계단계 성능은 반드시 염두에 두어야 한다.

**성능을 제한하는 설계를 피하라**

컴포넌트 또는 외부 시스템간 소통 방식은 완성 후 변경하기 가장 어려움

- API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등
- 시스템 성능을 심각하게 제한할 수 있다.

**API 설계 할 때, 성능에 주는 영향을 고려하라**

- public 타입을 가변으로 만들면, 불필요한 방어적 복사를 많이 유발
- 컴포지션으로 해결 가능한 상황을 상속 방식으로 설계할 경우
    - 상위 클래스에 영원히 종속, 성능 제약까지도 상속
- 인터페이스 대신 구현 타입을 사용하는 경우
    - 특정 구현체에 종속, 개선된 구현체가 나와도 사용 불가

**API 설계가 성능에 주는 영향** 

java.awt.Component 클래스의 getSize 메서드 예시

- 설계자는 가변인 Dimension 인스턴스를 반환하도록 결정
- 호출측에서 방어적 복사 인스턴스를 매번 생성해야만 함
- 다른 설계 방식
    - 불변으로 설계(이상적)
    - getWidth, getSize로 분리 → 기본 타입을 각각 반환
        - 기존 클라이언트는 여전히 getSize() 사용하며 피해

**성능을 위해 API를 왜곡하지 말자**

성능 문제는 해당 플랫폼이나, 하위 소프트웨어의 다음 버전에서 사라질 수도 있음

→ 왜곡된 API와 이를 지원하는데 드는 고통은 지속

깨끗하고 멋진 프로그램을 완성한 후에야 최적화를 고려하자

### **최적화 시도 이후로 성능을 측정하라**

시도한 최적화 기법이 성능을 눈에 띄게 높이지 못하는 경우가 많다

- 심지어 나빠지는 경우도 있음

주요 원인은? 성능 악화 부분을 추측하기 어렵기 때문

**90%의 시간을 단 10%의 코드에서 사용한다는 사실을 기억하자**

**프로파일링 도구**

최적화 노력을 어디에 들여야 할지 찾는데 도움을 주는 도구

- 개별 메서드의 소비 시간, 호출 횟수 등의 런타임 정보 제공
- jmh와 같은 자바 코드의 성능을 보여주는 마이크로 벤치마킹 도구도 있음

**성능 모델이 덜 정교한 자바에서, 성능 측정의 중요성 훨씬 크다**

C, C++과는 달리, 기본 연산에 드는 상대적인 비용을 덜 명확하게 정의

- 코드와 명령 사이 ‘추상화 격차’로 성능 변화 예측이 어려움
- 구현 시스템, 릴리스, 프로세서마다 차이 또한 존재
    - 여러 자바, 하드웨어 플랫폼에서 구동한다면 최적화 효과를 각각 측정해야 함