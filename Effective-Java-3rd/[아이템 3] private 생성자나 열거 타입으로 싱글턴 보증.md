# [아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라

# 싱글턴이란

인스턴스를 오직 하나만 생성 할 수 있는 클래스

**예시**

함수와 같은 무상태 객체, 설계상 유일한 시스템 컴포넌트

**문제**

클래스를 싱글턴으로 만들면, 클라이언트를 테스트하기 어려워 질 수 있다.

타입을 인터페이스로 만들고, 이를 구현한 싱글턴이 아니라면 싱글턴 인스턴스를 Mock으로 대체할 수 없기 때문

**만드는 방식**

- *public static final 필드*
    - private 생성자는 초기화 시 딱 한 번 호출된다. public/protected 생성자가 없으므로 초기화 때 만들어진 인스턴스가 하나뿐임이 보장된다.
    - 다만, 권한이 있는 클라이언트가 리플렉션 API setAccessible을 사용해 private 생성자를 호출 할 수 있다. 이는 두 번째 객체 생성 시 예외를 던지게 해 해결할 수 있다.
    - 장점: 해당 클래스가 싱글턴임이 API에 명백히 드러나고 간결하다.
- *정적 팩터리 public static getInstance()*
    - 장점: API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다. 정적 팩터리의 메서드를 supplier로 사용할 수 있다.
    - 이러한 장점들이 굳이 필요하지 않다면 public static 필드 방식이 좋다.
- 원소가 하나인 열거 타입 선언 ← 대부분 상황에서 가장 좋은 방법
    - 하지만 Enum 외 클래스 상속해야 한다면 불가능

**직렬화**

위 1~2번 중 하나의 방식으로 만든 싱글턴 클래스를 직렬화하려면, 단순 Serializable 구현으로는 부족

- 모든 인스턴스 필드를 transient 선언하고 readResolve 메서드를 제공해야 한다.
- 그렇지 않으면 역직렬화할 때 마다 새로운 인스턴스가 만들어진다.