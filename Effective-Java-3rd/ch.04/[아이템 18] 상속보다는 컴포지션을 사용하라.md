# [아이템 18] 상속보다는 컴포지션을 사용하라

상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니고 위험하다.

- 같은 개발자가 통제하는 패키지 내에서라면 비교적 안전하지만 다른 패키지의 구체 클래스를 상속은 위험

### 상속의 단점

메서드 호출과는 달리, 캡슐화를 깨뜨린다.

- 상위 클래스 구현(변경 가능성)에 따라 하위 클래스 동작에 이상이 생길 수 있다.
- 예시
    - 원소가 몇 개 더해졌는지 계산하는 Custom HashSet
    - add() 재정의하여 호출 시 count++, addAll() 재정의하여 호출 시 count += c.size()
    - count가 중복 호출되는 이슈? → 상위 클래스의 addAll()이 내부적으로 add() 호출하기 때문

이와 같은 자기 사용 여부는 해당 클래스의 내부 구현 방식에 해당하므로, 

이게 정책인지, 다음 릴리즈에도 유지될지 알 수 없다.

- addAll 구현방식이 변경될 수도 있음
- addAll 메서드를 다른 방식으로 재정의 해도, 구현 시간, 오류 가능성, private 필드 접근 불가 이슈 등 단점

**하위 클래스가 깨지기 쉬운 다른 이유**

상위 클래스에, 모든 원소가 특정 조건을 만족해야 하는 신규 메서드 추가

→ 하위 클래스에서도 특정 조건에 맞게 모두 구현

→ 문제상황: 상위 클래스에 이 조건을 만족하지 않는 메서드가 추가되고, 하위 클래스에서 이 존재를 모른다면?

→ 하위 클래스에서 이 잘못된 메서드가 호출 될 수 있음

- 컬렉션에 편입된 HashTable, Vector 예시
    - HashTable 의 put()을 보완한 SecureHashTable
    - 이후 Map ← HashTable 이 되며, putAll 메서드가 put() 을 사용하지 않고 직접 데이터 추가

메서드 재정의가 이런 문제를 유발하므로, 새로운 메서드를 추가하는 방식을 사용한다면?

- 만약 상위에서 우연히 동일한 시그니처 & 다른 반환 타입을 추가한다면, 내 클래스는 컴파일도 되지 않음
- 반환 타입까지 같다면 재정의가 되어버려 동일 문제 발생

### 컴포지션으로 문제 해결

```java
public class InstrumentSet<E> extends ForwardingSet<E> {
  private int addCount = 0;
  
  public InstrumentedSet(Set<E> s) {
    super(s);
  }
  // ...
}

public class ForwardingSet<E> implements Set<E> {
  private final Set<E> s; // 위임(delegation)
```

컴포지션 방식으로 변경한 래퍼 클래스 (데코레이터 패턴)

- 임의의 Set에 계측 기능을 덧씌워 새로운 Set으로 만드는 것이 핵심
- 상속 방식은 구체 클래스 각각을 따로 확장해야 하지만, 이 구현은 어떤 Set 구현체라도 계측 가능

**컴포지션 + 전달** 클래스 조합은 넓은 의미로 **위임**(delegation) 이라고 부른다.

- 엄밀히는 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우

**주의사항**

래퍼 클래스는 단점이 거의 없지만, 콜백 프레임워크와는 어울리지 않음에 주의

- 콜백 프레임워크는 자기 자신의 참조를 다른 객체에 넘겨 다음 호출(콜백) 때 사용하도록 함
- 내부 객체는 래퍼의 존재를 모르니 대신 자신(this)의 참조를 넘기고, **콜백 때는 래퍼가 아닌 내부 객체를 호출**하게 됨 → ‘SELF’ 문제

성능 영향은 미미하므로, 재사용할 수 있는 전달 클래스를 인터페이스당 하나씩 만들어두면

원하는 기능의 래퍼 클래스를 손쉽게 구현할 수 있음

- 예시) 구아바는 모든 컬렉션 인터페이스용 전달 메서드를 전부 구현

### 상속 주의사항

하위 클래스가 반드시 상위 클래스의 ‘진짜’ 하위 타입, 즉 **is-a** 관계일 때만 상속이 이루어져야 한다.

(is-a 여도 안심하고 써서는 안됨)

- 정말 B(하위클래스)가 A(상위클래스) 인가? 라고 자문
- 확신할 수 없다면, 필수 구성요소가 아닌 구현 방법중 일부일 확률 높음
    - B에서는 A를 private 인스턴스로 두고 다른 방식으로 API 제공해야 하는 상황
- Stack → Vector, Properties → HashTable 이 자바 라이브러리의 안좋은 예시

### 잘못된 상속의 문제

- API가 내부 구현에 묶이고, 클래스 성능도 영원히 제한된다.
- 클라이언트가 노출된 내부에 직접 접근 가능 → 캡슐화 깨짐
- 사용자를 혼란스럽게 할 수 있다.
    
    ```java
    Properties p;
    // HashTable   Properties    
    p.get(key) != p.getProperty(key)
    
    ```
    
- [중요] 클라이언트가 상위 클래스를 직접 수정하여, 하위 클래스의 불변식을 해칠 수 있다.
    - Properties는 문자열 key-value로만 제한했으나, HashTable을 직접 호출해 불변식 해칠 수 있음
- 상위 클래스의 API는 결함이 없는가? 있다면 전파돼도 괜찮은가? → 아니라면 컴포지션