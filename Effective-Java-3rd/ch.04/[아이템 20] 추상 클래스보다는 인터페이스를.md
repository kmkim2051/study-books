# [아이템 20] 추상 클래스보다는 인터페이스를 우선하라

### 자바가 제공하는 다중 구현 메커니즘 두 가지

1. 인터페이스
2. 추상 클래스

자바 8부터 인터페이스도 디폴트 메서드를 제공 → 두 메커니즘 모두 **구현된 인스턴스 메서드**를 제공 가능

### 인터페이스의 장점

- 단일 상속 환경에서 추상 클래스 방식은 제약이 크지만, **인터페이스의 규약을 잘 지킨 클래스라면 다른 어떤 타입을 상속했든 같은 타입으로 취급**
- 기존 클래스에도 손쉽게 새로운 인터페이스 구현 가능
    - 요구하는 메서드를 추가하고, implements 구문만 추가하면 끝
- 믹스인 정의에 안성맞춤
    - 원래 메인 타입 이외에 **특정 선택적 행위를 제공한다고 선언**하는 효과
    - 선택적 기능을 혼합한다고 해서 믹스인이라고 부른다
- 계층구조가 없는 타입 프레임워크를 만들 수 있다.
    - 계층 구분이 애매한 여러 개념을 구현, 확장할 수 있는 유연성
    - 만약 클래스라면 속성이 N개일 때, 지원해야할 조합의 수는 2^N (조합 폭발 방지)
- 래퍼 클래스와 함께 사용해 기능을 향상시키는 안전하고 강력한 수단으로 활용
- 인터페이스 메서드의 명백한 구현 방법이 있다면, 디폴트 메서드로 제공해 생산성 향상 (문서화 필요)
    - equals, hashCode 는 디폴트로 제공해서는 안된다.
    - 인스턴스 필드를 가질 수 없고, public 아닌 정적 멤버도 가질 수 없다.
- 인터페이스 + 추상 골격 구현 → 추상 클래스의 장점까지 모두 취하는 방법
    - 인터페이스로는 타입 정의, 디폴트 메서드, 골격 구현 클래스는 나머지 메서드 구현
    - 단순 골격 구현을 확장하는 것 만으로 인터페이스 구현을 대부분 완료
        - **템플릿 메서드 패턴**
    - 인터페이스 이름이 Interface 라면, 골격 구현 클래스는 AbstractInterface로 짓는 관례
        - Set ← AbstractSet, Map ← AbstractMap
        - List<integer> intArrayAsList(int[] a) 예시
    - 추상 클래스처럼 구현을 도와주고, 추상 클래스의 타입 정의 제약에서는 자유롭다.
    - 골격 구현을 확장하는 것으로 인터페이스 구현이 거의 끝나지만, 유일한 방법은 아님
        - 구조상 골격 구현을 확장하지 못하면 인터페이스를 직접 구현해야 함
        - 인터페이스 구현 클래스에서 골격 구현 확장 private 내부 클래스 정의, 위임하는 방법도 존재
        - simulated multiple inheritance 라고 하며, 다중 상속의 장점 취하고 단점 제거
- 골격 구현 작성 방법
    - 인터페이스 메서드 중 다른 메서드들의 구현에 사용되는 **기반 메서드 선정**
        - 이 기반 메서드들이 골격 구현에서 추상 메서드가 됨
    - 기반 메서드들을 사용해 직접 구현할 수 있는 메서드는 모두 디폴트 메서드로 제공
        - equals, hachCode 같은 Object 메서드는 제외함을 유념
    - 모두 기반 메서드 또는 디폴트 메서드가 된다면 → 굳이 골격 구현 클래스 생성할 필요 없음
        - 그렇지 않다면 남은 메서드들을 골격 구현 클래스에 작성한다.
    - Map.Entry 예시
        - getKey, getValue 는 확실한 기반 메서드 (setValue도 포함 가능)
        - equals, hashCode는 디폴트로 제공해서는 안되므로 골격 구현 클래스에 구현
        - 코드
        Map.Entry 나 그 하위 인터페이스에서는 Object 메서드를 재정의 할 수 없기 때문에
        이 골격 구현을 제공할 수 없다.
        
        ```java
        public abstract class AbstractMapEntry<K, V> implements Map.Entry<K, V> {
          // 변경 가능 엔트리는 반드시 이 메서드를 재정의
          @Override
          public V setValue(V value) {
            throw new UnSupportedOperationException();
          }
          
          // Map.entry의 일반 규약 구현
          @Override
          public boolean equals(Object o) {
            // ... 
          }
          // hashCode, toString
         
        ```
        
- 골격 구현은 기본적으로 상속 사용을 가정하므로, 설계 및 문서화 지침을 모두 따라야 한다.
- 단순 구현은 골격 구현의 작은 변종으로, AbstractMap.SimpleEntry가 예시
    - 상속을 위해 인터페이스를 구현했지만, 추상 클래스가 아닌 동작하는 가장 단순한 구현에 해당