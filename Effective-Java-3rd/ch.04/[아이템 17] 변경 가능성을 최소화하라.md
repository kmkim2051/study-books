# [아이템 17] 변경 가능성을 최소화하라

### 불변 클래스란?

인스턴스의 내부 값을 수정할 수 없는 클래스

- String, 기본 타입 박싱 클래스, BigInteger 등

가변 클래스보다 설계, 구현, 사용이 쉬우며 오류 가능성도 적다.

### 불변 클래스를 만들기 위한 규칙

- 객체의 상태 변경 메서드를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 객체 상태 변경하는 사태를 방지
- 모든 필드를 final 로 선언한다.
    - 인스턴스를 동기화 없이 다른 스레드로 전달해도 문제 없음을 보장하는데 필요
- 모든 필드를 private 으로 선언한다.
    - 필드가 참조하는 가변 객체를 클라이언트가 직접 접근, 수정하는 일 방지
    - 기본 타입, 불변 객체는 public final 로만 선언해도 되지만, 유연한 내부 구현 변경을 위해서 지양
- 자신 외에는 내부 가변 컴포넌트에 접근할 수 없도록 한다.
    - 가변 객체 필드가 하나라도 있다면, 클라이언트에서 해당 객체 참조를 얻을 수 없도록 해야 한다.
    - 생성자, 접근자, readObject 에서 방어적 복사 수행

### 불변 클래스 예시

```java
public final class Complex {
  private final double re;
  private final double im;
  
  // 생성자, getter
  // ...
  
  public Complex plus(Complex c) {
    return new Complex(re + c.re, im + c.im);
  }
  // ... 이하 유사 메서드
  
  // equals, hashcode, toString
}
```

사칙연산 메서드는 인스턴스 자신을 수정하지 않고, **새로운 인스턴스를 만들어 반환**

**함수형 프로그래밍**

위 예시처럼, 피연산자에 함수를 적용해 결과를 반환하지만 **피연산자(원본 객체) 자체는 그대로**인 프로그래밍 패턴

→ 불변 영역의 비율이 높아짐

### 불변의 장점

**기본적인 장점**

- 단순하다. 별다른 노력을 기울이지 않아도 영원히 불변으로 남는다.
- 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.
    - 어떤 스레드도 영향을 줄 수 없으니 안심하고 공유할 수 있다.
    - 한 번 만든 인스턴스를 재활용하기 쉽고, 권장한다.
        
        ```java
        public static final ZERO = new Complex(0, 0);
        ```
        

**심화된 장점**

- 자주 사용되는 인스턴스를 캐싱하여 중복 생성을 막는 **정적 팩터리** 제공 가능
    - 박싱된 기본 타입 클래스, BigInteger가 해당
    - 메모리 사용량과 GC 비용이 감 소
    - 클라이언트 변경 없이 캐시 기능 등 추가 가능
- 방어적 복사도 필요 없음
    - clone 메서드, 복사 생성자는 제공하지 않는 게 좋다.
- 자유롭게 공유하고, 불변 객체끼리 내부 데이터 공유 가능
    - BigInteger 클래스는 내부에서 부호(int), 크기(int[]) 사용
    - negate 메서드에서 부호가 반대인 값을 생성할 때, 원본 인스턴스와 같은 배열을 공유 가능
- 객체 생성 시 불변 객체들을 구성요소로 사용할 때의 장점
    - 구조가 복잡해도 불변식 유지 수월
    - Map의 key, Set의 원소로 쓰기 좋다 → 내부 값이 바뀔 걱정을 하지 않아도 됨
- 실패 원자성(failure atomicity)을 제공한다.
    - 메서드는 예외 발생 후에도, 여전히 유효한 상태여야 함
    - 불변 객체의 메서드는 내부 상태를 변경하지 않으니 이를 만족

**불변 클래스의 단점**

- 값이 다르면 반드시 독립된 객체로 만들어야 함
    - 경우의 수가 많다면 모두 만드는데 큰 비용이 든다.
    - 백만 비트짜리 BigInteger에서 비트 하나만 수정한다면?
        - 원본과 한 비트 다른 백만 비트 인스턴스 생성해야 함
        - BigSet과 같은 가변 클래스가 이런 경우에는 유리
- 객체 완성을 위해 많은 단계가 필요하고, 중간 단계 객체는 모두 버려진다면 성능 문제 커짐
    - 다단계 연산을 예측하여 기본 기능으로 제공 → 단계마다 객체 생성 필요 없음
    - BigInteger는 모듈러 지수 같은 가변 동반 클래스를 package private (이하 p-p)으로 포함
        - 수학교과서 뒤에 상용로그표 있는 느낌인가?
- 클라이언트의 복잡한 연산을 정확히 예측할 수 있다면, p-p로 충분
    - 그렇지 않다면? 이 클래스를 public 으로 제공하는 것이 최선
    - String 클래스 (가변동반: StringBuilder, StringBuffer)가 대표적인 예시
        - 위에 상용로그는 좀더 값적인 측면이고, 행위가 더 중요한듯

### 불변 클래스 만드는 설계 방법

final 클래스 외에 상속을 막는 더 유연한 방법

→ 모든 생성자를 private 또는 p-p로 만들고, public 정적 팩터리 제공

**<코드 예시>**

```java
public class Complex {
  private final double re;
  private final double im;
  
  private Complex(double re, double im) {
	  // ...
  }
  public static Complex valueOf(double re, double im) {
    return new Complex(re, im);
  }
  //...
```

이 방식이 최선인 경우가 많다. 외부에서 볼 수 없는 p-p 구현 클래스를 만들어 활용할 수 있으니 유연성 증가

→ 패키지 외부에서 본 이 객체는 사실상 final 이다. (다른 클래스에서 확장할 수 없기 때문)

### 불완전한 BigInteger, BigDecimal

BigInteger, BigDecimal 설계 당시에는 불변 객체가 완전한 final 이어야한다는 인식이 부족

→ 메서드가 모두 재정의 가능, 하위 호환성으로 인해 수정 못했음

→ 신뢰할 수 없는 클라이언트로부터 해당 인스턴스를 받는다면, **방어적으로 사용할 것**

```java
public static BigInteger safeInstance(BigInteger val) {
  return val.getClass() == BigIteger.class ? 
          val : new BigInteger(val.toByteArray());
}
```

### 완화된 불변 클래스 규칙

불변 클래스는 모든 필드가 final 이고, 어떤 메서드도 객체를 수정할 수 없어야 한다.

→ 약간 과하고, 성능을 위해 다음과 같이 완화할 수 있다.

> 어떤 메서드도 객체의 상태 중, 외부에 비치는 값을 변경할 수 없다.
> 

어떤 불변 클래스는 계산 비용이 큰 값을 나중에 (처음 쓰일 때) 계산하여 non-final 필드에 캐싱

- 객체가 불변이므로 항상 같은 값임을 보장하기 때문에 가능한 기술
- hashCode 등이 예시 (불변이 아니라면 동기화까지 고려해야 한다는 내용 있었음)

### 직렬화 시 주의점

Serializable 구현하는 불변 클래스의 내부에 가변 객체 참조 필드가 있다면,

- readObject 또는 readResolve 메서드를 반드시 제공하거나
- ObjectOutputStream.writeUnshared, ObjectInputStream.readUnshared 를 사용해야 한다.
- 그렇지 않으면 공격자가 가변 인스턴스를 만들 수 있음 (아이템 88)

### 정리

- 게터가 있어도 세터를 무조건 만들지는 말자
- 클래스는 꼭 필요한 경우가 아니면 불변이어야 한다.
- 단순한 값 객체는 불변으로, 무겁고 복잡한 객체도 불변으로 만들 수 있는지 고민해야 함.
    - 성능 이슈라면, 가변 동반 클래스를 public 으로 제공
- 불변으로 만들 수 없다면, 변경 부분을 최소한으로 줄이자.
    - 합당하게 변경될 필드를 제외하고는 전부 private final 로 선언
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 객체를 생성해야 한다.
    - 생성자와 정적 팩터리 외의 어떤 초기화 메서드도 public 으로 제공해서는 안된다.
- CountDownLatch 클래스가 이상의 원칙을 잘 방증
    - 가변 클래스지만 상태의 수가 많지 않고, 인스턴스 생성 후 한 번 사용하면 끝