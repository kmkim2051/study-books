# [아이템 19] 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

### 상속을 고려한 설계와 문서화란?

상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

- 자기 사용 (self-use) 에 해당

**클래스의 API로 공개된 메서드에서, 자신의 재정의 가능한 메서드를 호출한다면?**

호출 사실, 호출 순서, 호출 결과의 영향을 API 설명에 적시해야 한다. (거의 모든 발생 가능한 상황)

- 백그라운드 스레드, 정적 초기화 과정에서도 호출 발생 가능

**Implementation Requirements**

메서드의 내부 동작 방식을 설명하는 문서 요소

- 메서드 주석에 @implSpec 태그를 추가하면 자바독 도구가 생성한다.

**java.util.AbstractCollection 예시**

```java
public boolean remove(Object o)
```

- 특정 메서드 (iterator) 재정의 시 미치는 영향
- iterator 메서드로 얻은 반복자가 remove 메서드에 미치는 영향 등을 정확히 설명

**좋은 API 문서의 요건과 대치**

- 좋은 API 문서는 ‘어떻게’(내부 구현)가 아닌 ‘무엇’을 하는지를 설명해야 함
- implSpec과 같은 내용은 ‘어떻게’ 를 설명하는 안타까운 예시
    - 상속이 캡슐화를 해치기 때문에 일어나는 현상
- 클래스를 안전하게 상속하게 하려면 내부 구현 방식 설명이 필수적임

### 효율적인 하위 클래스를 만드는 다른 방법

클래스 내부 동작 과정에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드로 공개해야 할 수도 있음

- java.util.AbstractList :: removeRange 예시

List 구현체의 최종 사용자는 이 메서드에 관심이 없지만, 하위 클래스에서 clear 메서드 성능을 높이기 위해 설명

### 상속용 클래스 설계 시 protected 메서드를 정하는 방법?

정답은 없다. 하위 클래스를 만들어 시험해보는 것이 최선 (’유일’하다고 설명함)

- 3개 정도의 하위 클래스를, 총 2명 이상이 작성해봐야 함
- 하위 클래스 여럿 만들 동안 사용되지 않는 protected는 private이어야 할 가능성 큼

### 상속용으로 설계한 클래스는 배포 전 반드시 검증해야 한다.

널리 쓰일 클래스를 상속용으로 설계한다면 큰 책임이 따른다.

- 문서화한 내부 사용 패턴, protected 메서드 및 필드 구현하며 선택한 결정 등
- 클래스 성능과 기능에 영원한 족쇄가 될 수 있음. (특히 하위호환성 문제)

그러므로 배포 전 반드시 하위 클래스를 만들어 검증해야 한다.

### 상속용 클래스의 생성자는 직접이든 간접이든 재정의 가능 메서드를 호출해서는 안된다.

하위 클래스는 인스턴스가 완성되기 전에, 생성자에서 상위 클래스의 생성자를 먼저 호출함

→ 상위 클래스의 생성자에서 재정의 가능한 메서드를 호출하면, 하위 클래스에서 재정의한 해당 메서드가 호출

→ 생성자에서 초기화하는 값에 의존한다면, 값이 제대로 세팅되기 전이므로 에러 발생 가능성 높음

### Clonable, Serializable 인터페이스의 복잡성

두 인터페이스는 상속용 설계의 어려움을 더 심화시킨다.

- clone, readObject 메서드는 생성자와 비슷한 효과
    - 직간접적으로 재정의 가능 메서드를 호출해서는 안됨
    - clone: 하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에, 재정의한 메서드 먼저 호출
    - readObject: 하위 클래스 상태가 역직렬화 되기 전 재정의한 메서드부터 호출
- 특히 clone은 깊은 복사가 제대로 구현되지 않으면 원본 객체에 피해
- Serializable 구현한 상속용 클래스가 readResolve, writeReplace를 포함한다면
    - private으로 선언하면 하위 클래스에서 무시되므로 protected로 선언

### 결론

**상속용으로 설계한 클래스가 아니면, 상속을 금지하자**

- final class로 선언
- 생성자를 private 또는 package-private으로 선언하고 public 정적 팩터리 제공

**굳이 상속을 허용해야 한다면?**

클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 문서로 남기기

**클래스 동작을 유지하며 재정의 가능 메서드를 사용하는 코드를 제거하는 방법**

각 재정의 가능 메서드는 private Helper메서드로 옮기고, 모두 이를 호출하도록 수정