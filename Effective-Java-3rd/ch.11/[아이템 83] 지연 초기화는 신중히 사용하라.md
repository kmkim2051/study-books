# [아이템 83] 지연 초기화는 신중히 사용하라

**지연 초기화**

필드의 초기화 시점을 처음 필요시까지 늦추는 기법

- 값이 전혀 쓰이지 않으면 초기화도 결코 일어나지 않음
- 정적 필드와 인스턴스 필드 모두 사용 가능
- 주로 최적화 용도로 쓰이나, 초기화 시 순환 문제를 해결하는 효과도 있음

**필요할 때 까지는 하지 말라**

지연 초기화는 양날의 검 = 생성 시 **초기화 비용은 줄지만, 필드 접근 비용은 커짐**

→ 실제 초기화 비용, 초기화된 필드 호출 횟수에 따라 실제로는 성능 하락할 수도 있음

**지연 초기화가 필요한 경우**

해당 필드를 사용하는 인스턴스의 비율이 낮고, 초기화 비용이 큰 경우

- 실제 효과 여부는 적용 전후 성능을 측정해보는 방법 뿐

**멀티스레드 환경은 지연 초기화 까다롭다**

지연 초기화하는 필드를 여러 스레드를 공유한다면, 반드시 동기화해야 함

**대부분 상황에서 일반 초기화가 지연 초기화보다 낫다**

- 일반적인 인스턴스 필드 초기화
    - `private final FieldType field = computeFieldValue();`
- 인스턴스 필드의 지연 초기화 - synchronized
    - 초기화 순환성을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자 (명확하고 간단)
    - 한 번에 한 스레드만 초기화 경로에 들어오므로 순환 충돌 확률이 크게 감소
    
    ```java
    private FieldType field;
    
    private synchronized FieldType getField() {
      if (field == null)
        field = computeFieldValue();
      return field;
    }
    ```
    

**지연 초기화 홀더 클래스**

성능 때문에 **정적 필드를 지연 초기화**해야 한다면, 지연 초기화 홀더 클래스 관용구 사용

- 클래스는 처음 쓰일 때 비로소 초기화된다는 특성 이용

```java
private static class FieldHolder {
  static final FieldType field = computeFieldValue();
}

private static FieldType getField() { return FieldHolder.field; }

/*
1. getField가 처음 호출되는 순간 FieldHodler.field 읽힘
2. FieldHolder 클래스 초기화
*/
```

→ getField 메서드가 필드 접근 시 동기화를 하지 않으니 성능 하락 원인 없음

**이중 검사 관용구**

성능 때문에 **인스턴스 필드**를 지연 초기화해야 한다면 이중검사 관용구 사용

- 초기화된 필드에 접근 시 동기화 비용을 없애준다
- 동기화 없이 한번, 동기화하여 한번 더 검사 → 두 번째 검사에서도 초기화되지 않았다면 초기화
- 초기화된 이후로는 동기화하지 않으므로 반드시 `volatile` 로 선언

```java
private volatile FieldType field;

private FieldType getField() {
  FieldType result = field;
  if (result != null) {
    return result;
  }
  
  synchronized(this) {
    if (field == null) {
      field = computeFieldValue();
    }
    return field;
  }
}
```

- result 변수가 필요한 이유?
    - 변수가 이미 초기화된 상황에서는 그 필드를 딱 한 번만 읽도록 보장하는 역할
    - 필수는 아니지만, 성능을 높여주는 저수준 동시성 프로그래밍 표준 방법
    - volatile 읽기 비용과 미묘한 메모리 가시성 차이
- 정적 필드에 적용할 필요는 없다 (홀더 클래스 방식이 나음)
- 반복 초기화해도 상관없는 인스턴스 필드는 두 번째 검사를 생략할 수 있다
    - 단일 검사 관용구
    
    ```java
    private volatile FieldType field;
    
    private FieldType getField() {
      FieldType result = field;
      if (result == null)
        field = result = computeFieldValue();
      return result;
    }
    ```
    

**이번 아이템의 초기화 기법은 기본 타입과 객체 타입 모두 적용 가능**

- 기본 타입일 경우 null 대신 0과 비교

**volatile 한정자 제거해도 되는 경우**

모든 스레드가 필드 값을 재계산해도 상관 없고, 필드 타입이 long, double이 아닌 기본 타입

- racy single-check 관용구라고 불림 (보통 쓰지 않는다)