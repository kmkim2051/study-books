# [아이템 84] 프로그램 동작을 스레드 스케줄러에 기대지 말라

**스레드 스케줄러**

- 여러 스레드가 실행 중이면, 운영체제의 스레드 스케줄러가 **어떤 스레드를 얼마나 오래 실행**할지 결정
- 구체적인 스케줄링 정책은 운영체제마다 다를 수 있다.
    - 잘 작성된 프로그램이라면 이 정책에 휘둘려서는 안된다

**→ 정확성이나 성능이 스케줄러에 따라 달라지는 프로그램은 이식성이 낮다.**

**견고하고 이식성 좋은 프로그램 작성**

실행가능한 **스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것**이 핵심

- 스레드 스케줄러가 고민할 분량을 줄이기 위함
- 실행 준비가 된 스레드들은 작업 완료할 때까지 계속 실행하도록 만든다.

**실행 가능한 스레드 수와 전체 스레드 수는 구분해야 함**

- 전체 스레드 수는 훨씬 많을 수 있고, 대기 중인 스레드는 실행 불가능

**실행 가능한 스레드 수를 적게 유지하는 기법**

각 스레드가 작업 완료 후에는, **다음 작업이 생길 때 까지 대기**하도록 하는 것

→ 스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안된다.

- 실행자 프레임워크 예시
    - 스레드 풀 크기를 적절히 설정하고, 작업은 짧게 유지
    - 단, 작업이 너무 짧으면 작업 분배 부담이 커져 성능 하락 가능

**스레드가 바쁜 대기(busy waiting) 상태가 되면 안된다**

공유 객체 상태가 바뀔 때 까지 쉬지 않고 검사해서는 안된다는 뜻

```java
// 끔찍한 CountDownLatch
// 하나 이상의 스레드가 필요 없이 실행 가능한 상태 -> 성능과 이식성 하락
public class SlowCountDownLatch {
  private int count;
  
  public SlowCountDownLatch(int count) {
    if (count < 0)
      throw new IllegalArgumentException(count + " < 0");
    this.count = count;
  }
  
  // busy waiting: 조건 만족하기 전까지 while문 실행
  **public void await() {
    while (true) {
      synchronized(this) {
        if (count == 0)
          return;
      }
    }
  }**
  
  public synchronized void countDown() {
    if (count != 0)
      count--;
  }
}
```

특정 스레드가 CPU 시간을 충분히 얻지 못한 프로그램을 보더라도, `Thread.yield` 는 쓰지 말자

- 증상은 호전돼도 이식성 문제 발생 가능
- JVM에 따라 효과가 없거나 오히려 느려질 수도 있음
- 테스트할 수단도 없음

→ 차라리 애플리케이션 구조를 바꿔 동시 실행 가능한 스레드 수가 적어지도록 하자 (경쟁 자체 감소)

**동시 실행 가능한 스레드 수가 많아지면**

1. **컨텍스트 스위치 비용 증가** (캐시 flush, 레지스터 복원 등)
2. **락 경합(lock contention)** 증가
3. **스케줄링 예측 불가** → 특정 스레드가 CPU를 거의 못 잡는 **굶김(starvation)** 가능성

**Thread.yield**

- 현재 실행 중인 스레드가 남은 타임슬라이스를 포기
- 같은 우선순위의 다른 스레드에 실행 기회 양보하도록 힌트
- JVM, OS scheduler가 반드시 **실행할거라는 보장 없음**
- 대안
    - Lock, Semaphore 등 명시적 제어
    - 스레드 풀 사용 (ExecutorService)
    - 백프레셔, 이벤트 기반 처리

**결론**

- 프로그램 동작을 스레드 스케줄러(우선순위 조정)에 기대지 말자
- 스레드 스케줄링은 이미 잘 동작하는 프로그램의 퀄리티를 올리는데 써야한다.
- 간신히 동작하는 프로그램을 고치는 용도로 써서는 안됨