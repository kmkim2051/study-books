# [250605][아이템 13-14]

# 목차

- [아이템 13] clone 재정의는 주의해서 진행하라
- [아이템 14] Comparable을 구현할지 고려하라

---

# [아이템 13] clone 재정의는 주의해서 진행하라

### **Cloneable**

복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스

아래의 여러 문제에도 불구하고 Cloneable 방식은 널리 쓰이고 있음

### **문제**

- clone 메서드는 Cloneable이 아닌 Object 에 protected 로 선언되어 있음
→ Cloneable 인터페이스 구현만으로는 외부에서 clone 메서드를 호출할 수 없음
- 리플렉션으로 가능하지만, 100% 성공 보장하지 않음
    - 해당 객체가 접근이 허용된 clone 메서드를 제공한다는 보장이 없음

### **Cloneable 인터페이스의 역할**

Object 의 protected 메서드인 **clone**의 동작 방식을 결정

- Marker interface 로서, Object.clone() 이 필드 단위 복사를 수행하도록 허용하는 ‘신호 역할’만 수행

Cloneable을 구현한 클래스의 인스턴스에서 clone 호출

→ 객체의 필드를 하나하나 복사한 객체를 반환

→ 그렇지 않은 클래스에서는 CloneNotSupportedException 던짐

<aside>
💡

인터페이스를 이례적으로 사용한 예이니 따라하지는 말자.

</aside>

### 실무에서의 Cloneable

clone 메서드를 public 으로 제공하며, 사용자는 복제가 제대로 이루어지기를 기대

- 위험하고 모순적인 메커니즘 = 생성자 호출 없이 객체 생성 가능

### **clone 메서드의 허술한 일반 규약**

객체의 복사본을 생성해 반환한다. ‘복사’의 정확한 뜻은 구현 클래스에 따라 다를 수 있으며, 일반적인 의도는 다음과 같다.

- 어떤 객체 x에 대해 **x.clone() ≠ x 는 참**이다.
- **x.clone().getClass() == x.getClass()** 도 참이다.
    - 위의 두 요구를 반드시 만족해야 하는 것은 아니다.
- **x.clone().equals(x)** 일반적으로 참이지만, 필수는 아니다.
- 관례상, 이 메서드가 반환하는 객체는 **super.clone**을 호출해 얻어야 한다.
    - 이 클래스와 (Object 제외) 상위 클래스가 이 관례를 따른다면 다음은 참이다.
    - **x.clone().getClass() == x.getClass()**
- 관례상, 반환 객체와 원본 객체는 독립적이어야 한다.
    - 복제된 객체의 내부 상태가 원본 객체와 **서로 참조를 공유하지 않도록 분리**되어 있어야 함
    - 이를 만족하려면 super.clone으로 얻은 객체의 필드 중 일부를 반환 전에 수정해야 할 수도 있다.

강제성이 없다는 점만 빼면 생성자 체이닝(생성자에서 super() 호출)과 유사한 메커니즘

clone 메서드가 super.clone이 아닌, **생성자를 호출해 얻은 인스턴스를 반환**해도 컴파일러는 정상 동작

→ 하위 클래스에서 super.clone을 호출하면 의도하지 않은 클래스의 인스턴스가 만들어져 에러 발생

→ clone을 재정의한 클래스가 final이라면 하위 클래스가 없으니 관례를 무시해도 안전하지만, Cloneable을 구현할 이유 또한 없음

### 제대로 동작하는 Cloneable 구현

먼저 super.clone 을 호출한다. (원본의 완벽한 복제본)

1. 모든 필드가 기본 타입 또는 불변 객체 참조라면 여기서 끝
2. 불변 클래스는 굳이 clone 메서드를 제공하지 않는 것이 좋다

가변 상태를 참조하지 않는 클래스용 clone 메서드

```java
@Override
pubilc PhoneNumber clone() {
  try {
    return (PhoneNumber) super.clone();
  } catch (CloneNotSupportedException e) { 
		// 일어날 수 없음
    // CloneNotSupportedException 은 사실 unchecked 였어야 했다고 함
    throw new AssertionError(); 
    
  }
}
```

- 메서드 동작을 위해 클래스 선언에 Cloneable 구현 선언을 추가
- Object.clone은 Object를 반환하지만, PhoneNumber::clone은 PhoneNumber 반환
    - 자바의  공변 반환 타이핑에 의한 것으로, 권장하는 방식
        
        [공변](%5B250605%5D%5B%E1%84%8B%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A6%E1%86%B7%2013-14%5D%202084d82fc33b8081be71f8521b972c27/%E1%84%80%E1%85%A9%E1%86%BC%E1%84%87%E1%85%A7%E1%86%AB%202084d82fc33b808aa434cfa4c3f42347.md)
        

### 가변 객체 참조 clone 문제

**Stack 예시**

```java
public class Stack {
  private Object[] elements;
  // ...
  public Stack() {
    this.elements = new Object[DEFAULT_INITIAL_CAPACITY];
  }
  // ...
}
```

clone 메서드가 단순히 super.clone 결과를 그대로 반환한다면?

→ 복사본 Stack 인스턴스는 원본 Stack 인스턴스와 동일한 내부 배열 참조 (불변 해침)

Stack 클래스의 하나뿐인 생성자를 호출하면 (새로운 객체) 이러한 상황은 일어나지 않음

**가변 상태를 참조하는 클래스용 clone**

```java
@Override
public Stack clone() {
  try {
    Stack result = (Stack) super.clone();
    result.elements = elements.clone();
    return result;
  }
  //...
```

- elements.clone 결과를 형변환할 필요는 없음
    - 배열의 clone은 런타임과 컴파일 타임 모두 원본 배열과 똑같은 배열 반환
- elements가 final 이라면? 작동하지 않음
    - Cloneable 아키텍처는 ‘가변 객체 참조 필드는 final로 선언’ 용법과 충돌

**해시테이블용 clone**

잘못된 clone 메서드 - 가변 상태를 공유

```java
@Override
public HashTable clone() {
  try { 
    HashTable result = (HashTable) super.clone();
    result.buckets = buckets.clone();
    return result;
  }
  // ...
```

복제본은 별도의 버킷 배열을 소유 (but) 원본과 같은 연결 리스트(next)를 참조

→ 각 버킷을 구성하는 연결 리스트를 복사해야 함

**복잡한 가변 상태를 갖는 클래스용 재귀적 clone 메서드**

```java
// 이 엔트리가 가리키는 연결 리스트를 재귀적으로 복사
Entry deepCopy() {
  return new Entry(
    key, 
    value, 
    (next == null) ? null : next.deepCopy()
  );
}
// ...
@Override
public HashTable clone() {
  try {
    HashTable result = (HashTable) super.clone();
    result.buckets = new Entry[buckets.length];
    for (int i = 0; i < buckets.length; i++) {
      if (buckets[i] != null) 
        result.buckets[i] = buckets[i].deepCopy();
    return result;
		// ...
```

버킷이 너무 길지 않다면 잘 작동하나, 리스트 원소 수만큼 스택 프레임을 소비하여 스택 오버플로우를 일으킬 위험 존재

→ deepCopy를 반복문으로 변경

```java
Entry deepCopy() {
  Entry result = new Entry(key, value, next);
    
  for (Entry p = result; p.next != null; p = p.next) {
    // p.next 를 deep copy
    p.next = new Entry(p.next.key, p.next.value, p.next.next);
  }
  return result;
}
```

**복잡한 가변 객체를 복제하는 마지막 방법**

1. 먼저 super.clone 을 호출하여 얻은 객체의 모든 필드를 초기 상태로 설정
2. 원본 객체의 상태를 다시 생성하는 **고수준 메서드** 호출
    1. 해시테이블 예시
    buckets 필드 초기화한 다음, 원본 테이블의 모든 key-value에 대해 복제본 테이블의 put(key, value)를 호출해 둘의 내용이 일치하도록 설정
    2. 고수준 API 는 간결하지만 저수준 구현에 비해 비교적 느리고, 필드 단위 객체 복사를 우회하므로 Cloneable 아키텍처와는 어울리지 않음
3. clone에서는 (생성자와 마찬가지로) 재정의될 수 있는 메서드를 호출하지 않아야 함
    1. 하위 클래스에서 재정의한 메서드 호출 시, 원본과 복제본의 상태가 달라질 가능성이 큼
    2. (2-a)의 put 메서드는 final 또는 private 이어야 한다.
4. public인 clone 메서드에서는 throws절을 없애야 사용하기 편하다
5. 상속용 클래스는 Cloneable을 구현해서는 안된다.
    1. protected + 예외 선언으로 구현을 하위 클래스에서 선택하도록 하기
    2. clone 메서드를 final 로 설정하고, 예외 던지기
6. Cloneable 구현한 thread-safe 클래스는 clone 메서드 역시 동기화해줘야 함
7. <요약>
    1. Cloneable 구현 클래스는 clone 재정의
    2. 접근 제한자는 public, 반환 타입은 클래스 자기 자신
    3. super.clone을 먼저 호출, 객체 참조는 내부 모두 깊은 복사
    4. 단, 일련번호나 고유 ID는 기본/불변 타입이라도 수정해줘야 함

### 복사 생성자와 복사 팩터리

이미 Cloneable을 구현한 클래스를 확장하는 경우가 아니라면, 대부분 나은 선택지

- 언어 모순적이고 위험한 객체 생성 메커니즘 사용하지 않음
- 엉성한 규약에 기대지 않고, final 용법과 충돌하지 않음
- 불필요한 예외를 던지지 않고, 형변환도 필요하지 않음
- 해당 클래스가 구현한 **‘인터페이스’타입의 인스턴스**를 받을 수 있음
    - 범용 컬렉션 구현체는 Collection 이나 Map 타입을 받는 생성자 제공
        
        ```java
        List<String> original = List.of("apple", "banana", "cherry");
        List<String> copy = new ArrayList<>(original);
        
        Map<String, Integer> original = Map.of("one", 1, "two", 2);
        Map<String, Integer> copy = new HashMap<>(original);
        ```
        

더 정확한 이름는 변환 생성자(conversion), 변환 팩터리

**복사 생성자**

자신과 같은 클래스의 인스턴스를 인수로 받는 생성자

- 서브클래싱을 고려하지 않는, 단일 클래스의 상태 복제에 사용

```java
public Yum(Yum yum) {...}
```

**복사 팩터리**

복사 생성자를 모방한 정적 팩터리

- 캐싱, 타입 다양성, 서브클래싱 등을 고려하거나 외부 노출 용도로 사용

```java
public static Yum newInstance(Yum yum) {...}
```

### 더 알아보기

**with 방식으로 일부 필드만 바꾼 새로운 인스턴스 반환 → 불변 객체 생성 시 용이**

record에서 구현한 예시

```java
public record Person(String name, int age) {

    public Person withName(String name) {
        return new Person(name, this.age);
    }

    public Person withAge(int age) {
        return new Person(this.name, age);
    }
}
// 사용 예시
Person p1 = new Person("Alice", 30);
Person p2 = p1.withAge(31);  // 이름은 그대로, 나이만 변경

System.out.println(p2); // Person[name=Alice, age=31]
```

lombok에서 제공하는 with

```java
public class Person {
    @With
    private final String name;
    @With
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
// 자동 생성 메서드
public Person withName(String name) { ... }
public Person withAge(int age) { ... }

// 사용 예시
Person p1 = new Person("Alice", 30);
Person p2 = p1.withAge(31);

System.out.println(p2); // Person[name=Alice, age=31]
```

---

# [아이템 14] Comparable을 구현할지 고려하라

### Comparable 인터페이스의 compareTo

**Object의 equals와의 차이점** 

단순 동치성 비교 뿐 아니라 순서까지 비교, 제네릭

Comparable을 구현한 클래스의 인스턴스는 자연적인 순서가 있음을 의미

→ Arrays.sort(a) 와 같이 손쉽게 정렬 가능

검색, 극단값 계산, 자동 정렬 컬렉션 관리 또한 손쉽게 가능

**코드 예시**

```java
public class WordList {
  public static void main(String[] args) {
    // String이 Comparable을 구현한 덕분
    Set<String> s = new TreeSet<>();
    Collections.addAll(s, args);
    System.out.println(s);
  }
}
```

자바 플랫폼 라이브러리의 모든 값 클래스와 열거 타입이 Comparable을 구현함

→ 알파벳, 숫자, 연대와 같이 순서가 명확한 값 클래스는 **반드시** Comparable을 구현하자

### compareTo 메서드의 일반 규약

이 객체와 주어진 객체를 비교한다. 

- 주어진 객체보다 **작으면 음의 정수, 같으면 0, 크면 양의 정수**를 반환
- 비교할 수 없는 타입의 객체 → ClassCastException 발생

Comparable을 구현한 클래스는 모든 x, y, z에 대해

- x.compareTo(y) == -(y.compareTo(x))
    - x.compareTo(y) 는 y.compareTo(x) 가 예외를 던질 때에 한해 예외를 던져야 한다
    - **순서를 바꿔도 예상한 결과가 나와야 함**
- 추이성을 보장한다.
    - x.compareTo(y) > 0 && y.compareTo(z) > 0 → x.compareTo(z) > 0
- x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compareTo(z))
    - **크기가 같은 객체들끼리는 어떤 객체와 비교해도 항상 결과가 같아야 함**
    - compare 결과가 0이다 → 동등한 객체 → 제 3의 객체와 비교해도 일관된 순서

**즉, compareTo로 수행하는 동치성 검사도 equals와 같이 반사성, 대칭성, 추이성을 충족해야 함**

- 필수는 아니지만 꼭 지켜야 하는 규칙 (equals와의 관계)
    - (x.compareTo(y) == 0) == x.equals(y)
    - compareTo와 equals의 동치성 테스트 결과가 일치하도록 구현하는게 좋다.
        - 정렬된 컬렉션에 넣었을 시, 정의된 동작과 결과가 달라질 수 있음
        - 예시
        
        ```java
        BigDecimal("1.0") 
        BigDecimal("1.00")
        
        equals로는 다르지만(다른 객체)    -> HashSet에서는 구분된 객체  -> size = 2
        compareTo로는 동일하다 (대소비교) -> TreeSet에서는 동일 객체   -> size = 1
        ```
        
    - 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다.

### **비교 대상의 타입에 따른 equals와 compareTo의 차이**

- equals 메서드는 모든 객체에 대해 전역 동치관계를 부여함
    - 클래스 간 비교를 허용하긴 하지만, 일반적으로 동일 타입 간에만 비교하긴 함
- compareTo는 타입이 다른 객체를 신경쓰지 않아도 됨
    - 단순히 ClassCastException을 던져도 되며, 대부분 그렇게 함
- 다른 타입 사이의 비교도 가능하지만, 보통 공통 인터페이스를 매개로 이루어짐

### **compareTo 규약을 지키지 못하면, 비교를 활용하는 클래스와 어울릴 수 없음**

- 정렬된 컬렉션
    - TreeSet, TreeMap
- 검색과 정렬 알고리즘 활용하는 유틸리티 클래스
    - Collections, Arrays

### **확장 클래스 문제와 우회법**

equals와 마찬가지로, **확장 클래스에서 새로운 값 컴포넌트가 추가**되면 compareTo 규약을 지킬 방법이 없다.

우회법 또한 내부 인스턴스를 반환하는 ‘뷰 메서드 (asPoint)’ 제공 방식으로 동일하다.

### 작성 요령

작성 요령은 equals와 비슷하다.

**Comparable 은 타입을 인수로 받는 제네릭 인터페이스**
→ compareTo 메서드의 인수 타입은 컴파일 타임에 결정
→ 타입이 잘못되면 컴파일이 안되므로 타입 체크 및 형변환할 필요 없음

**null을 인수로 넣어 호출하면 NPE를 던져야 함**

compareTo(null) 은 NPE를 던져야 한다.

- compareTo를 호출하는 메서드에서 @NotNull 등의 애노테이션으로 명시하는 것이 좋을 듯

실제로도 null의 멤버에 접근하는 순간 예외가 던져질 것이다.

**compareTo는 각 필드가 동치인지 비교하는게 아닌, 순서를 비교한다. (큰지, 작은지, 같은지)**

**객체 참조 필드는 compareTo 메서드를 재귀적으로 호출하여 비교**

**Comparable 미구현 또는 비표준 비교는 비교자(Comparator)를 대신 사용**

직접 만들거나, 자바 기본 제공을 사용

[코드] 객체 참조 필드가 하나뿐인 비교자

```java
public final class CaseInsensitiveString implements Comparable<CaseInsensitveString> {
  public int compareTo(CIS cis) {
    return String.CASE_INSENSITVE_ORDER.compare(s, cis.s);
  }
  // ...
```

```java
// String.java
public static final Comparator<String>CASE_INSENSITIVE_ORDER
= new CaseInsensitiveComparator();
```

### compareTo의 이전 방식

책의 2판에서 권장한 내용

- 정수 기본 타입 필드 비교는 관계 연산자(>, <) 사용
- 실수 기본 타입 필드 비교는 정적 메서드 (Type.compare) 사용

자바 7부터는 박싱된 기본 타입 클래스들에 새로 추가된 정적 메서드 compare 사용 추천

- 일관된 결과 반환(-1, 0, 1) , null-safe
- 관계 연산자는 더이상 추천하지 않음

### 핵심 필드가 여러 개인 클래스의 비교

클래스에 핵심 필드가 여러 개라면, 어느 것을 먼저 비교하느냐가 중요 → 핵심 필드부터

**비교 결과가 0이 아니라면, 즉시 결과를 반환하자**

### 자바 8에 도입된 메서드 체이닝 방식

Comparator 인터페이스가, 일련의 비교자 생성 메서드(comparator construction method) 를 이용,

**메서드 체이닝 방식으로 비교자를 생성 가능**

<aside>
💡

간결하지만, 약 10% 정도의 성능 저하 발생 가능 (저자 피셜)

</aside>

```java
Comparator<PhoneNumber> CP 
  = comparingInt((PhoneNumber pn) -> pn.areaCode) // 타입 정보 넘겨줘야 함
      .thenComparingInt(pn -> pn.prefix)
      .thenComparingInt(pn -> pn.lineNum);

public int compareTo(PhoneNumber pn) {
  return CP.compare(this, pn);
}      
```

클래스 초기화 할 때, 비교자 생성 메서드 2개를 이용한다.

- comparingInt
    - 객체 참조를 int 타입 키에 매핑하는 **키 추출 함수**를 인수로 받아, 
    그 키를 기준으로 순서를 정하는 **비교자를 반환**하는 **정적 메서드**

```java
 public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor) {
   Objects.requireNonNull(keyExtractor);
   
   return (Comparator<T> & Serializable)
        (c1, c2) -> Integer.compare(
                      keyExtractor.applyAsInt(c1),
                      keyExtractor.applyAsInt(c2));
 }
```

- thenComparingInt
    - Comparator의 **인스턴스 메서드**로, int 키 추출자 함수를 입력받아 다시 비교자를 반환
        - 첫 번째 비교자 적용 후 **새로 추출한 키로 추가 비교를 수행**
    
    ```java
    default Comparator<T> thenComparingInt(ToIntFunction<? super T> keyExtractor) {
        return thenComparing(comparingInt(keyExtractor));
    }
    ```
    

**객체 참조용 메서드**

- comparing
    - 키 추출자 하나의 인수를 받는 메서드
    - 키 추출자, 비교자 두 개의 인수를 받는 메서드
    
    ```java
    // 키 추출자 하나의 인수를 받는 메서드
    // c1.compare(c2)
    public static <T, U extends Comparable<? super U>> Comparator<T> comparing(
            Function<? super T, ? extends U> keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
    }
    
    // 키 추출자, 비교자 두 개의 인수를 받는 메서드
    // comparator.compare(c1, c2)
    public static <T, U> Comparator<T> comparing(
            Function<? super T, ? extends U> keyExtractor,
            Comparator<? super U> keyComparator)
    {
        Objects.requireNonNull(keyExtractor);
        Objects.requireNonNull(keyComparator);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyComparator.compare(keyExtractor.apply(c1),
                                              keyExtractor.apply(c2));
    }
    ```
    
- thenComparing
    - 키 추출자, 비교자, (키 추출자+비교자) 의 세 가지 종류

### 값의 차를 기준으로 구현한 compare

추이성을 위반하는 코드

- 정수 오버플로를 일으키거나, 부동소수점 계산 방식 오류 발생 가능

```java
public int compare(Object o1, Object o2) {
  return o1.hashCode() - o2.hashCode();
}
```

대신 정적 compare 메서드나 Comparator 생성 메서드를 활용하자

```java
// 방법 1.
public int compare(Object o1, Object o2) {
  return Integer.compare(o1.hashCode(), o2.hashCode());
}

// 방법 2.
Comparator.comparingInt(o -> o.hashCode());
```