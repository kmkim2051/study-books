# [아이템 6] 불필요한 객체 생성을 피하라

같은 기능의 객체를 매번 생성하기보다는 하나를 재사용하는 편이 나을 때가 많다.

### **피해야 할 극단적인 예시**

```java
String s = new String("hello");
```

실행될 때마다 인스턴스를 새로 만든다.  생성자에 넘겨진 문자열 자체가 생성자로 만들 결과물과 완전히 똑같다.

반복문 내부에 있다면 쓸데없는 인스턴스가 수없이 만들어질 수 있다.

**개선**

```java
String s = "hello";
```

→ 동일 가상 머신 안에서 같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함을 보장 (JLS 3.10.5)

### **정적 팩터리 메서드**

생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 불필요한 객체 생성을 피할 수 있음

```java
Boolean(String) -> Boolean.valueOf(String)
```

생성자는 항상 새로운 객체를 만들지만, 팩터리 메서드는 그렇지 않다.

### **생성 비용이 비싼 객체**

비싼 객체가 반복해서 필요한 경우, 캐싱하여 재사용하길 권장

- 다만, 만들 객체가 비싼 객체인지 매번 명확히 알기 힘들다.

**예시**

String.matches를 사용하며 문제 발생

```java
static boolean isRomanNumeral(String s) {
  return s.matches("정규식A" + "정규식B");
}
```

메서드가 내부에서 만드는 정규표현식용 *Pattern* 인스턴스는 한 번 쓰고 버려져서 바로 GC 대상이 됨

*Pattern* 은 입력받은 정규표현식용 유한 상태 머신을 만드므로 인스턴스 생성 비용이 높다.

따라서 다음과 같이 불변 인스턴스를 클래스 초기화 과정에서 **직접 생성해 캐싱**하고, 메서드 호출 시마다 재사용

```java
public class RomanNumeral {
  private static final Pattern ROMAN = Pattern.compile("...");
  
  static boolean isRomanNumeral(String s) {
    return ROMAN.matcher(s).matches();
  }
}
```

성능 개선 뿐 아니라 코드의 의미가 더 잘 드러난다.

- 메서드가 처음 호출될 때 지연 초기화를 할 수 있지만, 코드가 복잡해지고 성능 개선은 미미하다.

### 불필요한 객체 생성

**불필요한 객체 생성을 하지 않는 경우**

- 어댑터
    - 실제 작업은 뒷단에 위임하고, 제2의 인터페이스 역할을 하는 객체
    - 뒷단 객체 하나만 관리하면 되므로, 객체 하나당 어댑터 하나로 충분

- 어댑터의 예시*: Map*의 *keySet* 인터페이스
    - keySet() 호출할 때 마다 새로운 Set 인스턴스가 만들어지는것이 아닌, 같은 Map 인스턴스와 연결된 일종의 View 객체가 반환
    - keySet()을 수정하면 원본 Map도 같이 변경

**불필요한 객체 생성 - 오토 박싱**

```java
Long sum = 0L;
for (long i = 0; i <= MAX; i++) {
  sum += i;
}
return sum;
```

sum 변수가 long이 아닌 Long으로 선언되어, 불필요한 Long 인스턴스가 다수 생성

- 책에서는 ‘231’개라고 했는데, 실제로는 21억개가 아닌가? 2^31이 잘못 번역된듯

### 방어적 복사와는 대조적인 내용

*[아이템 50] 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라*

**방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해**가, 필요 없는 객체 생성의 피해보다 훨씬 크다.

전자는 버그와 보안 구멍, 후자는 단순 성능 이슈