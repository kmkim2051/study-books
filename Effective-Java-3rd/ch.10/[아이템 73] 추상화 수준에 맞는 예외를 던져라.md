# [아이템 73] 추상화 수준에 맞는 예외를 던져라

**메서드가 저수준 예외를 처리하지 않고 전파해버리면**

작업과 관련 없는 예외가 튀어나오는 당황스러운 상황 발생

→ 프로그래머를 당황시킬 뿐 아니라, 내부 구현을 드러내어 상위 API 오염

→ 다음 릴리스에서 구현 방식 바꾸면 다른 예외가 튀어나와 기존 클라이언트를 깨지게 할 수도 있음

**상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다**

이를 예외 번역이라고 함

```java
try {
  ... // 저수준 추상화
} catch (LowerLevelException e) {
  throw new HigherLevelException(...);
}
```

**예외 번역의 예시**

AbstractSequentialList에서 수행하는 예외 번역

- AbstractSequentialList는 List 인터페이스의 골격 구현
- 예시의 예외 번역은 List<E> 인터페이스의 get 메서드 명세에 명시된 필수사항임

```java
/*
이 리스트 안의 지정한 위치의 원소 반환
@throws IndexOutOfBoundsException index가 범위 밖이라면 발생
*/
public E get(int index) {
  ListIterator<E> i = listIterator(index);
  try {
    return i.next();
  } catch (NoSuchElementException e) {
    throw new IndexOutOfBoundsException("인덱스: " + index);
  }
}
```

예외 번역 시, **저수준 예외가 디버깅에 도움이** 된다면? → **예외 체이닝** 사용

- 근본 원인인 저수준 에외를 고수준 예외에 실어 보내는 방식
- 별도의 접근자 메서드 (getCause)를 통해 꺼내 볼 수 있음

```java
try {
  ... // 저수준 추상화
} catch (LowerLevelException cause) {
  throw new HigherLevelException(cause);
}

// 예외 연쇄용 생성자
// 상위 클래스의 생성자에 '원인'을 건네줘, 최종적으로 Throwable 생성자까지 건네지게 됨
class HigherLevelException extends Exception {
  HigherLevelException(Throwable cause) {
    super(cause);
  }
}
```

대부분의 표준 예외는 예외 연쇄용 생성자를 포함

- 그렇지 않더라도 Throwable의 initCause 메서드를 이용해 ‘원인’ 삽입 가능
- 문제 원인을 프로그램에서 접근할 수 있게 해주며, 원인과 고수준 예외의 스택 정보 통합

**단순 예외 전파보다는 예외 번역이 우수하지만, 남용은 곤란**

가능한 저수준 메서드가 반드시 성공하도록 하여, **아래 계층에서 예외 발생하지 않도록 하는 것**이 최선

**차선책**

상위 계층에서 해당 예외를 조용히 처리하여, API 호출자에게 전파하지 않는 방법

- 적절한 로깅 기능을 활용해 기록해두는 것이 좋다
- 클라이언트에게 문제 전파하지 않으면서도 프로그래머가 로그 분석 및 조치 가능