# [아이템 76] 가능한 한 실패 원자적으로 만들라

### 실패 원자적

호출된 메서드가 실패하더라도, 해당 객체는 메서드 호출 전 상태를 유지해야 한다

### **메서드를 실패 원자적으로 바꾸는 방법**

- **불변 객체로 설계하는 것**
    - 태생적으로 실패 원자적이다.
    - 새로운 객체가 만들어지지 않을 수 있어도, 상태가 바뀌지 않음
- **가변 객체라면 → 작업 수행에 앞서 매개변수 유효성 검사**
    - 내부 상태 변경 전 잠재적 예외 가능성 필터링
    - 예시
    
    ```java
    public Object pop() {
      if (size == 0)
        throw new EmptyStackException();
      Object result = elements[--size];
      elements[size] = null;
      return result;
    }
    ```
    
    - 스택이 비었다면 여전히 예외를 던지지만, size 값이 음수가 되어 다음번 호출도 실패
    - 이때 던져질 ArrayIndexOutOfBoundsException은 추상화 수준이 상황에 어울리지 않는다.
    - 실패할 가능성이 있는 모든 코드를, 상태 변경 코드보다 앞에 배치하는 기법
        - 계산 수행 전에는 유효성을 검사할 수 없을 때 사용 가능
        - TreeMap의 경우, 비교 가능한 타입이어야 함 → 트리 변경 전 추가한다면 ClassCastException
- **임시 복사본에서 작업 수행 후 → 완료 시 원 객체와 교체**
    - 데이터를 임시 자료구조에 저장해 작업하는게 빠를 때 적용하기 좋은 방식
    - 예시 - 정렬 메서드의 경우, 입력 리스트 원소들을 접근이 빠른 배열에 옮겨 닮음
        - 성능 이점 + 정렬에 실패하더라도 원본 리스트 보존
- **작업 도중 발생하는 실패를 가로채는 복구 코드 작성**
    - 주로 디스크 기반 내구성 보장하는 자료 구조에 사용 (자주 쓰이는 방법은 아니다.)

### 실패 원자성은 항상 달성할 수 있는 것은 아니다

- 두 스레드가 동기화 없이 같은 객체 동시 수정 → 일관성 깨짐 → ConcurrentModificationException 을 잡아내도 안전한 상태라고 가정할 수 없음
- Error: 복구할 수 없으므로 AssertionError는 실패 원자적으로 만드려는 시도 필요 없음

**항상 실패 원자적으로 만들어야 하는 것도 아님**

비용이나 복잡도가 큰 연산인 경우가 해당

**메서드 명세에 기술한 예외라면, 예외 발생하더라도 객체 상태는 유지되어야 함**

- 지켜지지 않는다면 실패 시 상태를 설명에 명시해야 함
- 많은 API 문서가 지키지 못하고 있음