# [아이템 69] 예외는 진짜 예외 상황에만 사용하라

**예외를 완전히 잘못 사용한 코드**

직관적이지 않은 끔찍한 코드

```java
try {
  int i = 0;
  while(true) {
    range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```

- 배열의 원소를 순회하다가, 끝에 도착하면 예외를 발생시키며 종료
- 표준적인 관용구에 맞춰 작성했으면 이해하기 훨씬 쉬웠을 것
    
    ```java
    for (Mountain m : range)
      m.climb()
    ```
    

**예외를 써서 루프를 종료한 이유 추론**

- JVM은 배열에 접근할 때마다, 경계 검사
    - 반복문에도 이 검사를 명시하면 중복되므로 생략했을 것
- 옳은 추론이 아닌 이유
    - 예외는 예외 상황 용도이므로, JVM 구현자가 최적화 하지 않았을 가능성 높음
    - 코드를 try-catch 안에 넣으면 JVM 최적화 제한
    - 배열 순회하는 표준 관용구는, 중복 검사 수행하지 않고 이미 JVM이 최적화
    - 실제로 느림
- 반복문 내에 버그가 있다면, 버그를 숨겨 디버깅을 어렵게 할 수 있음
- 내부에서 다른 이유로 ArrayIndexOutOfBoundsException를 일으킨다면 묻힘

**→ 예외는 오직 예외 상황에서만 쓰자! 일상적 제어 흐름에 사용되어서는 안된다.**

**→ 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 과하게 노리지 말자**

### **API 설계시의 예외 처리**

잘 설계된 API는 클라이언트가 정상적인 처리 흐름에서 예외를 사용할 일이 없게 해야 한다.

**특정 상태에 의존**적인 메서드를 제공하는 클래스는, **상태 검사 메서드**도 제공해야 함

- Iterator → next (상태 의존적), hasNext (상태 검사 메서드)
- 

```java
// 상태 검사 메서드 덕분에 사용 가능한 for 표준 관용구
// for-each도 내부적으로 hasNext 사용
for (Iterator<Foo> i = collection.iterator(); i.hasNexst(); ) {
  Foo foo = i.next();
  // ...
}

// hasNext를 제공하지 않았다면? 클라이언트가 처리해줘야 함
try {
  Iterator<Foo> i = collection.iterator();
  while(true) {
    Foo foo = i.next();
  }
} catch (NoSuchElementException e) {
}
// 장황하고, 헷갈리고, 느리고, 버그를 숨기기도 함
```

### 상태 검사 메서드 대체 방안

- 빈 옵셔널 또는 null 같은 특수한 값 반환

상태검사 메서드, 옵셔널, null 중에 무얼 선택해야 할까?

- 외부 동기화 없이, 여러 스레드가 동시에 접근 가능하거나 상태가 변할 수 있다면
    - 옵셔널이나 특정 값 사용 (메서드 호출 사이에 객체 상태가 변할 수 있기 때문)
- 성능이 중요하고, 상태 검사 메서드가 상태 의존 메서드의 작업 일부를 중복 수행한다면
    - 옵셔널이나 특정 값 수행
- 다른 모든 경우는 상태 검사 메서드 방식이 나음!
    - 가독성 좋고, 잘못 사용 시 발견 가능
    - 상태 검사 메서드 호출을 잊었다면, 의존 메서드가 예외를 던져 버그 확실히 발생