# [아이템 70] 복구 가능하면 검사 예외, 프로그래밍 오류는 런타임 예외

### 자바의 throwable 타입 세가지

- 검사 예외
- 런타임 예외
- 에러

### 검사 예외

호출하는 쪽에서 복구하리라 여겨지는 상황에서 사용하라

→ 검사와 비검사 예외를 구분하는 기본 규칙

**호출자가 `catch` 로 잡아 처리하거나, 더 바깥으로 전파하도록 강제**

메서드 선언에 포함된 각 검사 예외는 메서드 호출 시 발생 유력한 결과임을 API 사용자에게 알려주는 것

→ API 설계자가 사용자에게 그 상황에서 회복해내라고 요구한 것

**사용자가 예외를 잡기만 하고 별다른 조치를 취하지 않는 것은 나쁜 생각**

---

### 두 가지 비검사 throwable

- 런타임 예외
- 에러

동작 측면에서는 다르지 않고, 프로그램에서 잡을 필요가 없거나 잡지 말아야 한다.

**→ 복구 불가능하거나, 더 실행해도 득보다 실이 많다는 뜻**

이런 throwable을 잡지 않은 스레드는 적절한 오류 메시지를 뱉으며 중단

---

### 런타임 예외

프로그래밍 오류를 나타낼 때 사용하자

- 대부분 API의 명세에 기록된 제약(전제조건)을 지키지 못한 경우 발생
- 예시: `ArrayIndexOutOfBoundsException` 배열 인덱스가 0~(size-1)을 벗어난 경우

**흔히 일어나는 문제 - 복구 가능한지, 프로그래밍 오류인지 명확히 구분 X**

자원 고갈 상황 → 말도 안되는 크기의 배열 할당한 프로그래밍 오류 ? **OR** 실제로 자원 부족 상황

- 복구 가능하다고 믿는다면 검사 예외 (일시적인 자원 부족)
- 그렇지 않다면 런타임 예외 (확신하지 못한다면 아마도 좋은 선택)

---

### 에러

- 보통 JVM이 더 이상 수행을 계속할 수 없는 상황 (자원 부족, 불변식 깨짐 등)
- Error 클래스를 상속해 하위 클래스를 만들지 말자 (업계 규약)
    - 상속하지 말아야 할 뿐 아니라, (AssertionError 제외하고는) throw문으로 던질 일도 없어야 한다.

**→ 우리가 구현할 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.**

---

**Exception, RuntimeException, Error를 상속하지 않는 throwable은 만들지 말자**

- 자바 언어 명세에서 직접 다루지는 않지만, 암묵적으로 일반적인 검사 예외처럼 다룬다
- 정상적인 검사 예외보다 나을 것도 없고, API 사용자를 헷갈리게 할 뿐

**예외 역시 객체다**

예외의 메서드는 상황 정보를 코드 형태로 전달하는데 쓰인다.

- 이런 메서드가 없다면, 프로그래머들은 오류 메시지를 파싱해 정보를 얻어야 함 → 아주 나쁜 습관
- JVM이나 릴리스에 따라 포맷이 달라질 수 있다 → 파싱한 결과가 깨지기 쉽고, 정상 동작하지 않을 수 있음

검사 예외는 복구 가능 조건에서 발생 → 호출자가 복구에 필요한 정보를 알려주는 메서드 제공이 중요

- 예시) 카드 잔고 부족을 의미하는 검사 예외 → 부족한 잔고를 알려주는 메서드 제공

### 정리

- 복구 가능 → 검사 예외
    - 복구 정보 메서드 제공하자
- 프로그래밍 오류 → 비검사 예외 (확실하지 않은 상황 포함)
- 검사예외도 아니고, 런타임 예외도 아닌 throwable → 사용 금지