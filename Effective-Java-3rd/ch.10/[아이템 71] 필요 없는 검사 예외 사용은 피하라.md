# [아이템 71] 필요 없는 검사 예외 사용은 피하라

### 검사 예외의 장단점

제대로 활용하면 API와 프로그램의 질을 높일 수 있다.

- 결과를 코드로 반환하거나 비검사 예외와 달리, **프로그래머가 처리하여 안정성을 높이게 해줌**
    - 과하면 쓰기 불편한 API가 될 수 있음
- 메서드 선언에 검사 예외가 있다면, 호출 코드에서는 `catch` 블록 또는 바깥으로 전파해야 함
    - 양쪽 모두 사용자에게는 부담
    - 스트림 안에서 직접 사용할 수 없으므로 부담 증가

### 검사 예외 vs 비검사 예외

**API를 제대로 사용해도 발생 가능하거나, 프로그래머가 의미 있는 조치를 취할 수 있다면 적합**

→ 둘 다 아니라면 비검사 예외를 사용하자

둘 중 무엇을 선택할지는 **프로그래머가 예외를 어떻게 다룰지 생각**해보면 알 수 있다.

다음과 같은 방법이 최선인가?

```java
} catch (TheCheckedException e) {
  throw new AssertionError(); // 일어날 수 없다!
}
// 또는
} catch (TheCheckedException e) {
  e.printStackTrace();
  System.exit(1);
}
```

더 나은 방법이 없다면 비검사 예외를 선택해야 한다.

### 검사 예외를 피하는 방법

단 하나의 검사 예외만 던질 때, 프로그래머의 부담 증가

- 다른 하나를 추가하는 경우라면, catch 문 하나 추가하면 끝
- 단 하나뿐이라면, 해당 예외를 위해 try문 추가, 스트림 사용 불가 등

검사 예외를 회피하는 가장 쉬운 방법 = **적절한 결과 타입을 담은 옵셔널 반환**

- 검사 예외 대신 빈 옵셔널을 반환한다.
- 이 방식의 단점
    - 예외 발생 이유 관련 부가 정보를 담을 수 없음
    - 예외는 구체적인 예외 타입, 관련 메서드들 활용 가능

**검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾸는 방법**

첫 메서드는 예외 던질 지 여부를 boolean으로 반환

```java
// Before
try {
  obj.action(args);
} catch (TheCheckedException e) {
  // ... 예외 처리
}

// After
if (obj.actionPermitted(args)) {
  obj.action(args);
} else {
  // ... 예외 처리
}
```

- 모든 상황에 적용할 수는 없지만, 쓰기 편한 API를 제공할 수 있다.
- 반드시 성공할 걸 안다거나, 실패 시 스레드 중단을 원한다면 한 줄로 작성해도 무방
    - `obj.action(args)`
    - 이 방식이 주로 쓰일 거로 판단되면 리팩터링이 바람직
- `actionPermitted` 메서드는 상태 검사 메서드 → 단점 존재
    - 외부 동기화 없이 여러 스레드가 접근 가능하거나, 외부 요인에 의해 상태 변할 수 있다면 부적절
    - `actionPermitted` 가 `action` 메서드 일부를 중복 수행한다면, 성능 이슈로 부적절 가능성