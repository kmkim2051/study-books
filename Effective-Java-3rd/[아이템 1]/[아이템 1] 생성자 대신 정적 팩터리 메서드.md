# [아이템 1] 생성자 대신 정적 팩터리 메서드를 고려하라

### public 생성자

클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단

### 정적 팩터리 메서드 (static factory method)

클래스의 인스턴스를 반환하는 단순한 정적 메서드

- 참고, 디자인 패턴의 팩터리 메서드와는 다르다.

**[코드 1] 정적 팩터리 메서드 예시**

```jsx
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```

**장점**

1. 이름을 가질 수 있다.
    1. 생성자와는 달리, 잘 지은 정적 팩터리 메서드 이름은 반환될 객체의 특성을 쉽게 묘사할 수 있다.
        1. BigInteger(int, int, Random) <  **BigInteger.probablePrime(int, int, Random)**
        2. 하나의 시그니처로는 생성자를 하나만 만들 수 있다. 별도 설명 없이는 파악 어려움
2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
    1. 불변 클래스는 인스턴스를 미리 생성하거나 캐싱할 수 있다. (위 [코드 1]참고)
        1. 생성 비용이 큰 동일 객체가 반복 생성되는 상황을 막을 수 있다.
    2. 인스턴스 통제 클래스가 되어 객체 생성 방식을 통제할 수 있다.
        1. 싱글턴, 인스턴스화 불가, 불변 값 클래스에서 동치 인스턴스 단일 존재 보장, 플라이웨이트
3. 반환 타입의 하위 타입 객체를 반환할 수 있다.
    1. 반환할 객체의 클래스를 자유롭게 선택할 수 있는 유연성 제공
        1. API 작성 시 구현 클래스 공개 없이 객체 반환할 수 있어 작은 API 유지 가능
    2. 자바 8 이전에는 인터페이스에 정적 메서드 선언할 수 없어 ~s 붙은 동반 클래스가 관례
        1. Collections 가 그 예시 (Objects 도 여기에 해당인듯)
        2. 정적 필드와 정적 멤버 클래스는 public이어야 하므로 이런 package-private 클래스는 여전히 필요
    3. 컬렉션 프레임워크는 실제 클래스를 공개하지 않아 API 의 개념적인 무게를 낮춤
        1. 구현 클래스가 아닌 인터페이스만으로 다루게 됨
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    1. 하위 타입이기만 하면 어떤 클래스의 객체를 반환해도 상관없다.
        1. EnumSet 클래스가 예시. 클라이언트는 인스턴스의 실제 구현 타입을 모르므로 성능을 개선하며 어느 한 클래스를 삭제해도 문제가 없다.
5. 정적 팩터리 메서드 작성 시점에, 반환 객체의 클래스가 존재하지 않아도 된다. ‘서비스 제공자 프레임워크’를 만드는 근간이 된다.
    1. 여러 변형
        1. 서비스 접근 API는 공급자가 제공하는 것보다 더 풍부한 서비스 인터페이스를 클라이언트에 반환할 수 있다 (브릿지 패턴)
        2. 의존 객체 주입도 강력한 서비스 제공자의 한 예시
    
    [서비스 제공자 프레임워크](%5B%E1%84%8B%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A6%E1%86%B7%201%5D%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%83%E1%85%A2%E1%84%89%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%E1%84%85%E1%85%B3%202074d82fc33b80059573f7d1fc84e499/%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%8C%E1%85%A6%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%202074d82fc33b80c999cdfc9688b93b1f.md)
    

**단점**

1. 상속을 하려면 public 또는 protected 생성자가 필요하다.
    1. 컴포지션을 유도하고 불변 타입에 필요하니 오히려 장점일 수도 있음
2. 프로그래머가 찾기 어렵다.
    1. 생성자처럼 API 설명에 명확히 드러나지 않음 → 사용자가 명명 방식을 통해 해결해야 함
        1. from: 매개변수 하나, of: 매개변수 여러개, valueOf: 더 자세한 버전
        2. (get)instance: 매개변수로 명시한 인스턴스를 반환하나, 같은 인스턴스임은 보장하지 않음
        3. create, newInstance: 새로운 인스턴스를 생성 및 반환함을 보장
        4. getType: 다른 클래스에 팩터리 메서드를 정의 (newType: 생성, type: 간결)