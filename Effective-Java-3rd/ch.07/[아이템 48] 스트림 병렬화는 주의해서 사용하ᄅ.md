# [아이템 48] 스트림 병렬화는 주의해서 사용하라

자바는 동시성 프로그래밍 측면에서, 항상 앞서가던 언어

- 초기 릴리즈(1996년), wait/notify 지원
- 자바 5, java,util.conurrent 프레임워크 지원
- 자바 7, 고성능 병렬 분해 프레임워크인 fork, join 패키지 지원
- 자바 8, parallel 메서드를 통한 병렬 파이프라인 스트림 지원

하지만 **올바른 동시성 프로그램 작성은 어려운 일**

- 안정성(safety), 응답 가능(liveness) 상태 유지가 중요

**메르센 소수 예시**

```java
primes.map(p -> TWO.pow(p.intValueExact()).subtranc(ONE)
  .filter(m -> m.isPrime(50))
  .limit(20)
  .forEach(println)
```

단순히 실행하면 10초 정도 완료 → 속도 증가를 위해 paralle()을 호출한다면?

아무것도 출력하지 못하고 cpu만 90% 잡아먹음

- 스트림 라이브러리가 병렬화 방법을 찾기 못했기 때문

**데이터 소스가 Stream.iterate 거나 중간 연산으로 limit을 쓰면, 파이프라인 병렬화로 성능 개선 기대할 수 없음**

→ 스트림 파이프라인을 마구잡이로 병렬화 하면 안된다.

### 스트림 병렬화의 효과가 좋은 경우

데이터를 **원하는 크기**로 정확하고 손쉽게 **나눌 수 있어야** 함

→ 일을 다수의 스레드에 분배하기 좋다

**참조 지역성**이 뛰어나다 (배열)→ 이웃한 원소의 참조들이 메모리에 연속해서 저장

- 낮으면 스레드는 주 메모리 ↔ 캐시 메모리 전송 시간 동안 대기하게됨

**병렬화 효과가 좋은 스트림 소스**

- 스트림 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스
- 배열, int, long 범위

### **종단 연산의 동작 방식이 효율에 영향을 주는 경우**

- 종단 연산이 대부분의 비중을 차지하는 순차 연산이라면 병렬화는 제한될 수 밖에 없음
- 가장 적합한 병렬 연산: 축소 (reduction)
    - 파이프라인에서 만들어진 모든 원소를 하나로 합친느 작업
    - reduce, min, max, count, sum 등 하나를 선택해 수행
- anyMatch, allMatch, nonMatch와 같이 조건에 따라 바로 반환되는 메서드도 적합
- 가변 축소 방식인 collect는 적합하지 않음 → 합치는 부담이 크기 때문

### 스트림을 잘못 병렬화하면

성능이 나빠질 뿐 아니라 예상 못한 동작이 발생할 수 있음

**안전 실패 :** 결과가 잘못되거나 오동작하는 것

- 병렬화 파이프라인이 사용하는 mapper, filters 등의 함수 객체가 명세대로 동작하지 않을 때 발생
- Stream 명세는 이에 대한 엄중한 규약을 정의
    - reduce 연산의 accumulator, combiner 는 **결합법칙, 간섭받지 않음, 무상태 만족**
    - 순차 수행하면 규약을 어겨도 올바른 결과를 얻을 수 있지만, 병렬로 수행하면 실패할 것

**파이프라인이 수행하는 작업이 병렬화의 추가 비용을 상쇄하지 못한다면 성능 향상 미미할 수 있음**

- 코드 수 * 원소 수가 **수십만**은 되어야 성능 향상 효과

스트림 병렬화는 성능 최적화 수단이므로, 성능 테스트를 확실히 하자

- 보통 공통의 포크-조인 풀에서 수행되므로, 다른 시스템에 악영향을 줄 수도 있음

### 스트림 병렬화의 이점

조건만 잘 갖춰지면 parallel 메서드 하나로 코어 수에 비례하는 성능 향상 가능

- 머신러닝과 데이터 처리 같은 특정 분야

```java
static long pi(long n) {
  return LongStream.rangeClosed(2, n)
    .parallel() // n = 10^8 인 경우, 저자는 3.4배의 성능 향상(31 -> 9) 
    .mapToObj(BigIntger::valueOf)
    .filter(i -> i.isPrime(50))
    .count());
```

무작위 스트림을 병렬화하려면 ThreadLocalRandom 보다는 SplittableRandom을 이용하자.

- ThreadLocalRandom : 단일 스레드 용도로 구현되어 빠르지 않음
- SplittableRandom : 병렬 처리 용으로 설계되어 성능 선형 증가
- Random : 동기화 방식. 병렬 처리 때 사용하지 말것