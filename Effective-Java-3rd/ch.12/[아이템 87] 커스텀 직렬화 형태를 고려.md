# [아이템 87] 커스텀 직렬화 형태를 고려

### 기본 직렬화 형태 사용 시의 문제

- 일정에 쫓기면 “이번에는 적당히 동작만” → “다음 버전에 제대로 구현” 하는 경우가 많다
- `Serializable` 을 구현하고, 기본 직렬화 형태 사용한다면? 하위 호환성에 발이 묶임
    - BigInteger와 같은 경우

### 기본 직렬화 형태 사용이 괜찮은 경우

- 직접 설계하더라도 기본 형태와 거의 동일한 결과가 나올 경우에만 써야 함
- 어떤 객체의 기본 직렬화 형태는, 그 객체를 루트로 하는 **객체 그래프의 물리적 모습**을 효율적으로 인코딩
- 이상적인 직렬화 형태라면, 물리적인 모습과 독립된 **논리적인 모습만 표현**해야 함

→ 객체의 **물리적 표현 == 논리적 표현**이라면 기본 직렬화 형태라도 무방

```java
// 논리적으로 ‘이름, 성, 중간이름’ 3개의 문자열로 구성
public class Name implements Serializable {
  // 성, not null
  // @serial
  private final String lastName;
  
  // 이름, not null
  // @serial
  private final String firstName;
  
  // 중간이름, nullable
  // @serial
  private final String middleName;
}
```

**기본 직렬화 형태가 적합해도, 불변식 보장과 보안을 위해 `readObject` 제공이 필요한 경우 존재**

- 위 Name 예시에서는 `lastName, firstName` 이 null이 아님을 보장해야 함
- @serial: private 필드 설명을 API문서에 포함하라고 자바독에 알려주는 역할

### 직렬화 형태에 적합하지 않은 예시

```java
public final class StringList implements Serializable {
  private int size = 0;
  private Entry head = null;
  
  private static class Entry implements Serializable {
    String data;
    Entry next
    Entry previous;
  }
}
```

논리적 = 일련의 문자열 표현, 물리적 = 문자열을 이중 링크드 리스트로 연결

→ 기본 직렬화 시 **양방향 연결 정보를 포함한 모든 엔트리**를 기록

**객체의 물리적 표현과 논리적 표현의 차이가 클 때의 문제**

- 공개 API가 현재 내부 표현 방식에 영구히 묶인다.
    - 내부 표현을 바꾸더라도 이전 버전 호환을 지원해야 함
- 너무 많은 공간을 차지할 수 있다.
    - 앞 예시에서 엔트리, 연결 정보는 포함할 필요가 없음 (데이터만 필요)
- 시간이 너무 많이 걸릴 수 있다.
    - 직렬화 로직은 객체 그래프 위상 정보가 없으니 직접 순회해볼 수 밖에 없다.
- 스택 오버플로를 일으킬 수 있다.
    - 객체 그래프를 재귀 순회하며, 중간 규모(수백개 +a)에서도 스택 오버플로 발생 가능

### 합리적인 직렬화 형태

단순히 리스트가 포함한 문자열 형태 + 문자열 나열 정도 수준이면 충분

```java
public final class StringList implements Serializable {
  private transient int size = 0;
  private transient Entry head = null;
  
  private static class Entry {
    String data;
    Entry next;
    Entry previous;
  }
  
  /* 인스턴스 직렬화
  * @serialData 이 리스트 크기를 기록 후 모든 원소를 순서대로 기록
  */
  private void writeObject(ObjectOutputStream s) throws IOException {
    s.defaultWriteObject();
    s.writeInt(size);
    
    for (Entry e = head; e != null; e = e.next)
      s.writeObject(e.data);
  }
  
  private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    s.defaultReadObject();
    int numElements = s.readInt();
    
    // 모든 원소를 읽어 리스트에 삽입
    for (int i = 0; i < numElements; i++)
      add((String) s.readObject());
  }
}
```

- 모든 필드가 `transient` 라도 default 메서드를 호출하는 이유 (직렬화 명세에서 요구)
    - 향후 릴리스에서 non-transient 필드가 추가되더라도 상호 호환되기 때문
    - 신버전 직렬화 → 구버전에서 역질렬화 : 새로 추가된 필드들은 무시
    - 그렇지 않으면 `StreamCorruptException` 발생 가능
- 해시테이블의 예시
    - 해시테이블은 물리적으로 키-값 엔트리 버킷을 차례로 나열한 형태
    - 계산 방식은 구현에 따라, 계산 시마다 달라질 수 있음 → 기본 직렬화 시 심각한 문제

**transient를 생략해도 되는 경우**

- `defaultWriteObject` 호출 시 transient로 선언하지 않은 모든 인스턴스 필드가 직렬화
- transient로 선언해도 되는 인스턴스 필드는 모두 transient를 붙이자
    - 다른 필드에서 유도되는 값 (캐시된 해시)
    - JVM 실행 시마다 달라지는 값 (네이티브 자료구조를 가리키는 long 필드)
- 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 함
    - 커스텀 직렬화 사용 시 (StringList 예시) 대부분의 인스턴스 필드를 transient 선언

**기본 직렬화 사용 시 transient 필드들은, 역직렬화 시 기본값으로 초기화됨**

- 기본값을 그대로 사용하면 안되는 경우, default 메서드 호출 후 원하는 값으로 복원
- 또는 처음 사용 시 초기화

**객체 전체 상태를 읽을 때의 동기화 메커니즘을 직렬화에도 적용해야 한다**

모든 메서드를 synchronized 선언한 객체라면, writeObject도 똑같이 선언해야 한다.

```java
private synchronized void writeObject(ObjectOutputStream s) throws IOException {
  s.defaultWriteObject();
}
```

- 메서드 안에서 동기화하고 싶다면, 클래스 다른 부분의 **락 순서를 똑같이 따라야 한다 (교착상태 방지)**

**어떤 직렬화 형태든, 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자**

`private static final log serialVersionUID = 123L`;

- 직렬 버전 UID가 일으키는 잠재적 호환성 문제 방지
- 소소한 성능 향상 (런타임에 불필요한 생성 연산 방지)
- 어떤 long 값이든 상관 없음 (유틸리티 또는 직접 생성 가능, 고유할 필요도 없음)
- UID가 없는 클래스를 구버전 인스턴스와 호환 유지한 채 쓰고 싶으면, 그대로 사용해야 함
    - serialver 유틸리티 통해 얻을 수 있음
- 기존 버전 클래스와 호환성을 끊고 싶다면, UID값 변경하면 됨 → InvalidClassException
    - 해당 경우를 제외하고는 수정하지 말자